
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model bitacora
 * 
 */
export type bitacora = $Result.DefaultSelection<Prisma.$bitacoraPayload>
/**
 * Model departamentos
 * 
 */
export type departamentos = $Result.DefaultSelection<Prisma.$departamentosPayload>
/**
 * Model documentos
 * 
 */
export type documentos = $Result.DefaultSelection<Prisma.$documentosPayload>
/**
 * Model periodos
 * 
 */
export type periodos = $Result.DefaultSelection<Prisma.$periodosPayload>
/**
 * Model procesos
 * 
 */
export type procesos = $Result.DefaultSelection<Prisma.$procesosPayload>
/**
 * Model roles
 * 
 */
export type roles = $Result.DefaultSelection<Prisma.$rolesPayload>
/**
 * Model tipos_documentos
 * 
 */
export type tipos_documentos = $Result.DefaultSelection<Prisma.$tipos_documentosPayload>
/**
 * Model usuarios
 * 
 */
export type usuarios = $Result.DefaultSelection<Prisma.$usuariosPayload>
/**
 * Model usuarios_has_roles
 * 
 */
export type usuarios_has_roles = $Result.DefaultSelection<Prisma.$usuarios_has_rolesPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const procesos_estatus: {
  en_proceso: 'en_proceso',
  terminado: 'terminado'
};

export type procesos_estatus = (typeof procesos_estatus)[keyof typeof procesos_estatus]


export const roles_tipo: {
  admin: 'admin',
  capturista: 'capturista',
  revisor: 'revisor'
};

export type roles_tipo = (typeof roles_tipo)[keyof typeof roles_tipo]


export const procesos_resultado: {
  aprobado: 'aprobado',
  rechazado: 'rechazado',
  en_revision: 'en_revision'
};

export type procesos_resultado = (typeof procesos_resultado)[keyof typeof procesos_resultado]

}

export type procesos_estatus = $Enums.procesos_estatus

export const procesos_estatus: typeof $Enums.procesos_estatus

export type roles_tipo = $Enums.roles_tipo

export const roles_tipo: typeof $Enums.roles_tipo

export type procesos_resultado = $Enums.procesos_resultado

export const procesos_resultado: typeof $Enums.procesos_resultado

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Bitacoras
 * const bitacoras = await prisma.bitacora.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Bitacoras
   * const bitacoras = await prisma.bitacora.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.bitacora`: Exposes CRUD operations for the **bitacora** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bitacoras
    * const bitacoras = await prisma.bitacora.findMany()
    * ```
    */
  get bitacora(): Prisma.bitacoraDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.departamentos`: Exposes CRUD operations for the **departamentos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Departamentos
    * const departamentos = await prisma.departamentos.findMany()
    * ```
    */
  get departamentos(): Prisma.departamentosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.documentos`: Exposes CRUD operations for the **documentos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documentos
    * const documentos = await prisma.documentos.findMany()
    * ```
    */
  get documentos(): Prisma.documentosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.periodos`: Exposes CRUD operations for the **periodos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Periodos
    * const periodos = await prisma.periodos.findMany()
    * ```
    */
  get periodos(): Prisma.periodosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.procesos`: Exposes CRUD operations for the **procesos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Procesos
    * const procesos = await prisma.procesos.findMany()
    * ```
    */
  get procesos(): Prisma.procesosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.roles`: Exposes CRUD operations for the **roles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.roles.findMany()
    * ```
    */
  get roles(): Prisma.rolesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tipos_documentos`: Exposes CRUD operations for the **tipos_documentos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tipos_documentos
    * const tipos_documentos = await prisma.tipos_documentos.findMany()
    * ```
    */
  get tipos_documentos(): Prisma.tipos_documentosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.usuarios`: Exposes CRUD operations for the **usuarios** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usuarios
    * const usuarios = await prisma.usuarios.findMany()
    * ```
    */
  get usuarios(): Prisma.usuariosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.usuarios_has_roles`: Exposes CRUD operations for the **usuarios_has_roles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usuarios_has_roles
    * const usuarios_has_roles = await prisma.usuarios_has_roles.findMany()
    * ```
    */
  get usuarios_has_roles(): Prisma.usuarios_has_rolesDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.7.0
   * Query Engine version: 3cff47a7f5d65c3ea74883f1d736e41d68ce91ed
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    bitacora: 'bitacora',
    departamentos: 'departamentos',
    documentos: 'documentos',
    periodos: 'periodos',
    procesos: 'procesos',
    roles: 'roles',
    tipos_documentos: 'tipos_documentos',
    usuarios: 'usuarios',
    usuarios_has_roles: 'usuarios_has_roles'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "bitacora" | "departamentos" | "documentos" | "periodos" | "procesos" | "roles" | "tipos_documentos" | "usuarios" | "usuarios_has_roles"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      bitacora: {
        payload: Prisma.$bitacoraPayload<ExtArgs>
        fields: Prisma.bitacoraFieldRefs
        operations: {
          findUnique: {
            args: Prisma.bitacoraFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bitacoraPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.bitacoraFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bitacoraPayload>
          }
          findFirst: {
            args: Prisma.bitacoraFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bitacoraPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.bitacoraFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bitacoraPayload>
          }
          findMany: {
            args: Prisma.bitacoraFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bitacoraPayload>[]
          }
          create: {
            args: Prisma.bitacoraCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bitacoraPayload>
          }
          createMany: {
            args: Prisma.bitacoraCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.bitacoraDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bitacoraPayload>
          }
          update: {
            args: Prisma.bitacoraUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bitacoraPayload>
          }
          deleteMany: {
            args: Prisma.bitacoraDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.bitacoraUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.bitacoraUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bitacoraPayload>
          }
          aggregate: {
            args: Prisma.BitacoraAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBitacora>
          }
          groupBy: {
            args: Prisma.bitacoraGroupByArgs<ExtArgs>
            result: $Utils.Optional<BitacoraGroupByOutputType>[]
          }
          count: {
            args: Prisma.bitacoraCountArgs<ExtArgs>
            result: $Utils.Optional<BitacoraCountAggregateOutputType> | number
          }
        }
      }
      departamentos: {
        payload: Prisma.$departamentosPayload<ExtArgs>
        fields: Prisma.departamentosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.departamentosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departamentosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.departamentosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departamentosPayload>
          }
          findFirst: {
            args: Prisma.departamentosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departamentosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.departamentosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departamentosPayload>
          }
          findMany: {
            args: Prisma.departamentosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departamentosPayload>[]
          }
          create: {
            args: Prisma.departamentosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departamentosPayload>
          }
          createMany: {
            args: Prisma.departamentosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.departamentosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departamentosPayload>
          }
          update: {
            args: Prisma.departamentosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departamentosPayload>
          }
          deleteMany: {
            args: Prisma.departamentosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.departamentosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.departamentosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departamentosPayload>
          }
          aggregate: {
            args: Prisma.DepartamentosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDepartamentos>
          }
          groupBy: {
            args: Prisma.departamentosGroupByArgs<ExtArgs>
            result: $Utils.Optional<DepartamentosGroupByOutputType>[]
          }
          count: {
            args: Prisma.departamentosCountArgs<ExtArgs>
            result: $Utils.Optional<DepartamentosCountAggregateOutputType> | number
          }
        }
      }
      documentos: {
        payload: Prisma.$documentosPayload<ExtArgs>
        fields: Prisma.documentosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.documentosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.documentosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentosPayload>
          }
          findFirst: {
            args: Prisma.documentosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.documentosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentosPayload>
          }
          findMany: {
            args: Prisma.documentosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentosPayload>[]
          }
          create: {
            args: Prisma.documentosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentosPayload>
          }
          createMany: {
            args: Prisma.documentosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.documentosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentosPayload>
          }
          update: {
            args: Prisma.documentosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentosPayload>
          }
          deleteMany: {
            args: Prisma.documentosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.documentosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.documentosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentosPayload>
          }
          aggregate: {
            args: Prisma.DocumentosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocumentos>
          }
          groupBy: {
            args: Prisma.documentosGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentosGroupByOutputType>[]
          }
          count: {
            args: Prisma.documentosCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentosCountAggregateOutputType> | number
          }
        }
      }
      periodos: {
        payload: Prisma.$periodosPayload<ExtArgs>
        fields: Prisma.periodosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.periodosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$periodosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.periodosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$periodosPayload>
          }
          findFirst: {
            args: Prisma.periodosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$periodosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.periodosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$periodosPayload>
          }
          findMany: {
            args: Prisma.periodosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$periodosPayload>[]
          }
          create: {
            args: Prisma.periodosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$periodosPayload>
          }
          createMany: {
            args: Prisma.periodosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.periodosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$periodosPayload>
          }
          update: {
            args: Prisma.periodosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$periodosPayload>
          }
          deleteMany: {
            args: Prisma.periodosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.periodosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.periodosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$periodosPayload>
          }
          aggregate: {
            args: Prisma.PeriodosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePeriodos>
          }
          groupBy: {
            args: Prisma.periodosGroupByArgs<ExtArgs>
            result: $Utils.Optional<PeriodosGroupByOutputType>[]
          }
          count: {
            args: Prisma.periodosCountArgs<ExtArgs>
            result: $Utils.Optional<PeriodosCountAggregateOutputType> | number
          }
        }
      }
      procesos: {
        payload: Prisma.$procesosPayload<ExtArgs>
        fields: Prisma.procesosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.procesosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$procesosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.procesosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$procesosPayload>
          }
          findFirst: {
            args: Prisma.procesosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$procesosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.procesosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$procesosPayload>
          }
          findMany: {
            args: Prisma.procesosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$procesosPayload>[]
          }
          create: {
            args: Prisma.procesosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$procesosPayload>
          }
          createMany: {
            args: Prisma.procesosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.procesosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$procesosPayload>
          }
          update: {
            args: Prisma.procesosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$procesosPayload>
          }
          deleteMany: {
            args: Prisma.procesosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.procesosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.procesosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$procesosPayload>
          }
          aggregate: {
            args: Prisma.ProcesosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProcesos>
          }
          groupBy: {
            args: Prisma.procesosGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProcesosGroupByOutputType>[]
          }
          count: {
            args: Prisma.procesosCountArgs<ExtArgs>
            result: $Utils.Optional<ProcesosCountAggregateOutputType> | number
          }
        }
      }
      roles: {
        payload: Prisma.$rolesPayload<ExtArgs>
        fields: Prisma.rolesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.rolesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.rolesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          findFirst: {
            args: Prisma.rolesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.rolesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          findMany: {
            args: Prisma.rolesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>[]
          }
          create: {
            args: Prisma.rolesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          createMany: {
            args: Prisma.rolesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.rolesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          update: {
            args: Prisma.rolesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          deleteMany: {
            args: Prisma.rolesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.rolesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.rolesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          aggregate: {
            args: Prisma.RolesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoles>
          }
          groupBy: {
            args: Prisma.rolesGroupByArgs<ExtArgs>
            result: $Utils.Optional<RolesGroupByOutputType>[]
          }
          count: {
            args: Prisma.rolesCountArgs<ExtArgs>
            result: $Utils.Optional<RolesCountAggregateOutputType> | number
          }
        }
      }
      tipos_documentos: {
        payload: Prisma.$tipos_documentosPayload<ExtArgs>
        fields: Prisma.tipos_documentosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tipos_documentosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipos_documentosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tipos_documentosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipos_documentosPayload>
          }
          findFirst: {
            args: Prisma.tipos_documentosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipos_documentosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tipos_documentosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipos_documentosPayload>
          }
          findMany: {
            args: Prisma.tipos_documentosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipos_documentosPayload>[]
          }
          create: {
            args: Prisma.tipos_documentosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipos_documentosPayload>
          }
          createMany: {
            args: Prisma.tipos_documentosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tipos_documentosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipos_documentosPayload>
          }
          update: {
            args: Prisma.tipos_documentosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipos_documentosPayload>
          }
          deleteMany: {
            args: Prisma.tipos_documentosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tipos_documentosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tipos_documentosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipos_documentosPayload>
          }
          aggregate: {
            args: Prisma.Tipos_documentosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTipos_documentos>
          }
          groupBy: {
            args: Prisma.tipos_documentosGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tipos_documentosGroupByOutputType>[]
          }
          count: {
            args: Prisma.tipos_documentosCountArgs<ExtArgs>
            result: $Utils.Optional<Tipos_documentosCountAggregateOutputType> | number
          }
        }
      }
      usuarios: {
        payload: Prisma.$usuariosPayload<ExtArgs>
        fields: Prisma.usuariosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usuariosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usuariosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosPayload>
          }
          findFirst: {
            args: Prisma.usuariosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usuariosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosPayload>
          }
          findMany: {
            args: Prisma.usuariosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosPayload>[]
          }
          create: {
            args: Prisma.usuariosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosPayload>
          }
          createMany: {
            args: Prisma.usuariosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.usuariosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosPayload>
          }
          update: {
            args: Prisma.usuariosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosPayload>
          }
          deleteMany: {
            args: Prisma.usuariosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usuariosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.usuariosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosPayload>
          }
          aggregate: {
            args: Prisma.UsuariosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsuarios>
          }
          groupBy: {
            args: Prisma.usuariosGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsuariosGroupByOutputType>[]
          }
          count: {
            args: Prisma.usuariosCountArgs<ExtArgs>
            result: $Utils.Optional<UsuariosCountAggregateOutputType> | number
          }
        }
      }
      usuarios_has_roles: {
        payload: Prisma.$usuarios_has_rolesPayload<ExtArgs>
        fields: Prisma.usuarios_has_rolesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usuarios_has_rolesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuarios_has_rolesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usuarios_has_rolesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuarios_has_rolesPayload>
          }
          findFirst: {
            args: Prisma.usuarios_has_rolesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuarios_has_rolesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usuarios_has_rolesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuarios_has_rolesPayload>
          }
          findMany: {
            args: Prisma.usuarios_has_rolesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuarios_has_rolesPayload>[]
          }
          create: {
            args: Prisma.usuarios_has_rolesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuarios_has_rolesPayload>
          }
          createMany: {
            args: Prisma.usuarios_has_rolesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.usuarios_has_rolesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuarios_has_rolesPayload>
          }
          update: {
            args: Prisma.usuarios_has_rolesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuarios_has_rolesPayload>
          }
          deleteMany: {
            args: Prisma.usuarios_has_rolesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usuarios_has_rolesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.usuarios_has_rolesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuarios_has_rolesPayload>
          }
          aggregate: {
            args: Prisma.Usuarios_has_rolesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsuarios_has_roles>
          }
          groupBy: {
            args: Prisma.usuarios_has_rolesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Usuarios_has_rolesGroupByOutputType>[]
          }
          count: {
            args: Prisma.usuarios_has_rolesCountArgs<ExtArgs>
            result: $Utils.Optional<Usuarios_has_rolesCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    bitacora?: bitacoraOmit
    departamentos?: departamentosOmit
    documentos?: documentosOmit
    periodos?: periodosOmit
    procesos?: procesosOmit
    roles?: rolesOmit
    tipos_documentos?: tipos_documentosOmit
    usuarios?: usuariosOmit
    usuarios_has_roles?: usuarios_has_rolesOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type RolesCountOutputType
   */

  export type RolesCountOutputType = {
    usuarios_has_roles: number
  }

  export type RolesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuarios_has_roles?: boolean | RolesCountOutputTypeCountUsuarios_has_rolesArgs
  }

  // Custom InputTypes
  /**
   * RolesCountOutputType without action
   */
  export type RolesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolesCountOutputType
     */
    select?: RolesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RolesCountOutputType without action
   */
  export type RolesCountOutputTypeCountUsuarios_has_rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usuarios_has_rolesWhereInput
  }


  /**
   * Count Type Tipos_documentosCountOutputType
   */

  export type Tipos_documentosCountOutputType = {
    documentos: number
  }

  export type Tipos_documentosCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    documentos?: boolean | Tipos_documentosCountOutputTypeCountDocumentosArgs
  }

  // Custom InputTypes
  /**
   * Tipos_documentosCountOutputType without action
   */
  export type Tipos_documentosCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipos_documentosCountOutputType
     */
    select?: Tipos_documentosCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Tipos_documentosCountOutputType without action
   */
  export type Tipos_documentosCountOutputTypeCountDocumentosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: documentosWhereInput
  }


  /**
   * Count Type UsuariosCountOutputType
   */

  export type UsuariosCountOutputType = {
    documentos: number
    usuarios_has_roles: number
  }

  export type UsuariosCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    documentos?: boolean | UsuariosCountOutputTypeCountDocumentosArgs
    usuarios_has_roles?: boolean | UsuariosCountOutputTypeCountUsuarios_has_rolesArgs
  }

  // Custom InputTypes
  /**
   * UsuariosCountOutputType without action
   */
  export type UsuariosCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuariosCountOutputType
     */
    select?: UsuariosCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsuariosCountOutputType without action
   */
  export type UsuariosCountOutputTypeCountDocumentosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: documentosWhereInput
  }

  /**
   * UsuariosCountOutputType without action
   */
  export type UsuariosCountOutputTypeCountUsuarios_has_rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usuarios_has_rolesWhereInput
  }


  /**
   * Models
   */

  /**
   * Model bitacora
   */

  export type AggregateBitacora = {
    _count: BitacoraCountAggregateOutputType | null
    _avg: BitacoraAvgAggregateOutputType | null
    _sum: BitacoraSumAggregateOutputType | null
    _min: BitacoraMinAggregateOutputType | null
    _max: BitacoraMaxAggregateOutputType | null
  }

  export type BitacoraAvgAggregateOutputType = {
    id: number | null
    usuario_id: number | null
  }

  export type BitacoraSumAggregateOutputType = {
    id: number | null
    usuario_id: number | null
  }

  export type BitacoraMinAggregateOutputType = {
    id: number | null
    usuario_id: number | null
    rol: string | null
    accion: string | null
    ip: string | null
    descripcion: string | null
    fecha_inicio: Date | null
    fecha_act: Date | null
  }

  export type BitacoraMaxAggregateOutputType = {
    id: number | null
    usuario_id: number | null
    rol: string | null
    accion: string | null
    ip: string | null
    descripcion: string | null
    fecha_inicio: Date | null
    fecha_act: Date | null
  }

  export type BitacoraCountAggregateOutputType = {
    id: number
    usuario_id: number
    rol: number
    accion: number
    ip: number
    descripcion: number
    fecha_inicio: number
    fecha_act: number
    _all: number
  }


  export type BitacoraAvgAggregateInputType = {
    id?: true
    usuario_id?: true
  }

  export type BitacoraSumAggregateInputType = {
    id?: true
    usuario_id?: true
  }

  export type BitacoraMinAggregateInputType = {
    id?: true
    usuario_id?: true
    rol?: true
    accion?: true
    ip?: true
    descripcion?: true
    fecha_inicio?: true
    fecha_act?: true
  }

  export type BitacoraMaxAggregateInputType = {
    id?: true
    usuario_id?: true
    rol?: true
    accion?: true
    ip?: true
    descripcion?: true
    fecha_inicio?: true
    fecha_act?: true
  }

  export type BitacoraCountAggregateInputType = {
    id?: true
    usuario_id?: true
    rol?: true
    accion?: true
    ip?: true
    descripcion?: true
    fecha_inicio?: true
    fecha_act?: true
    _all?: true
  }

  export type BitacoraAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bitacora to aggregate.
     */
    where?: bitacoraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bitacoras to fetch.
     */
    orderBy?: bitacoraOrderByWithRelationInput | bitacoraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: bitacoraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bitacoras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bitacoras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned bitacoras
    **/
    _count?: true | BitacoraCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BitacoraAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BitacoraSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BitacoraMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BitacoraMaxAggregateInputType
  }

  export type GetBitacoraAggregateType<T extends BitacoraAggregateArgs> = {
        [P in keyof T & keyof AggregateBitacora]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBitacora[P]>
      : GetScalarType<T[P], AggregateBitacora[P]>
  }




  export type bitacoraGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bitacoraWhereInput
    orderBy?: bitacoraOrderByWithAggregationInput | bitacoraOrderByWithAggregationInput[]
    by: BitacoraScalarFieldEnum[] | BitacoraScalarFieldEnum
    having?: bitacoraScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BitacoraCountAggregateInputType | true
    _avg?: BitacoraAvgAggregateInputType
    _sum?: BitacoraSumAggregateInputType
    _min?: BitacoraMinAggregateInputType
    _max?: BitacoraMaxAggregateInputType
  }

  export type BitacoraGroupByOutputType = {
    id: number
    usuario_id: number | null
    rol: string | null
    accion: string | null
    ip: string | null
    descripcion: string | null
    fecha_inicio: Date | null
    fecha_act: Date | null
    _count: BitacoraCountAggregateOutputType | null
    _avg: BitacoraAvgAggregateOutputType | null
    _sum: BitacoraSumAggregateOutputType | null
    _min: BitacoraMinAggregateOutputType | null
    _max: BitacoraMaxAggregateOutputType | null
  }

  type GetBitacoraGroupByPayload<T extends bitacoraGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BitacoraGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BitacoraGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BitacoraGroupByOutputType[P]>
            : GetScalarType<T[P], BitacoraGroupByOutputType[P]>
        }
      >
    >


  export type bitacoraSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuario_id?: boolean
    rol?: boolean
    accion?: boolean
    ip?: boolean
    descripcion?: boolean
    fecha_inicio?: boolean
    fecha_act?: boolean
  }, ExtArgs["result"]["bitacora"]>



  export type bitacoraSelectScalar = {
    id?: boolean
    usuario_id?: boolean
    rol?: boolean
    accion?: boolean
    ip?: boolean
    descripcion?: boolean
    fecha_inicio?: boolean
    fecha_act?: boolean
  }

  export type bitacoraOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "usuario_id" | "rol" | "accion" | "ip" | "descripcion" | "fecha_inicio" | "fecha_act", ExtArgs["result"]["bitacora"]>

  export type $bitacoraPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "bitacora"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      usuario_id: number | null
      rol: string | null
      accion: string | null
      ip: string | null
      descripcion: string | null
      fecha_inicio: Date | null
      fecha_act: Date | null
    }, ExtArgs["result"]["bitacora"]>
    composites: {}
  }

  type bitacoraGetPayload<S extends boolean | null | undefined | bitacoraDefaultArgs> = $Result.GetResult<Prisma.$bitacoraPayload, S>

  type bitacoraCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<bitacoraFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BitacoraCountAggregateInputType | true
    }

  export interface bitacoraDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['bitacora'], meta: { name: 'bitacora' } }
    /**
     * Find zero or one Bitacora that matches the filter.
     * @param {bitacoraFindUniqueArgs} args - Arguments to find a Bitacora
     * @example
     * // Get one Bitacora
     * const bitacora = await prisma.bitacora.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends bitacoraFindUniqueArgs>(args: SelectSubset<T, bitacoraFindUniqueArgs<ExtArgs>>): Prisma__bitacoraClient<$Result.GetResult<Prisma.$bitacoraPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Bitacora that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {bitacoraFindUniqueOrThrowArgs} args - Arguments to find a Bitacora
     * @example
     * // Get one Bitacora
     * const bitacora = await prisma.bitacora.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends bitacoraFindUniqueOrThrowArgs>(args: SelectSubset<T, bitacoraFindUniqueOrThrowArgs<ExtArgs>>): Prisma__bitacoraClient<$Result.GetResult<Prisma.$bitacoraPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bitacora that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bitacoraFindFirstArgs} args - Arguments to find a Bitacora
     * @example
     * // Get one Bitacora
     * const bitacora = await prisma.bitacora.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends bitacoraFindFirstArgs>(args?: SelectSubset<T, bitacoraFindFirstArgs<ExtArgs>>): Prisma__bitacoraClient<$Result.GetResult<Prisma.$bitacoraPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bitacora that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bitacoraFindFirstOrThrowArgs} args - Arguments to find a Bitacora
     * @example
     * // Get one Bitacora
     * const bitacora = await prisma.bitacora.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends bitacoraFindFirstOrThrowArgs>(args?: SelectSubset<T, bitacoraFindFirstOrThrowArgs<ExtArgs>>): Prisma__bitacoraClient<$Result.GetResult<Prisma.$bitacoraPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Bitacoras that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bitacoraFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bitacoras
     * const bitacoras = await prisma.bitacora.findMany()
     * 
     * // Get first 10 Bitacoras
     * const bitacoras = await prisma.bitacora.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bitacoraWithIdOnly = await prisma.bitacora.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends bitacoraFindManyArgs>(args?: SelectSubset<T, bitacoraFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bitacoraPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Bitacora.
     * @param {bitacoraCreateArgs} args - Arguments to create a Bitacora.
     * @example
     * // Create one Bitacora
     * const Bitacora = await prisma.bitacora.create({
     *   data: {
     *     // ... data to create a Bitacora
     *   }
     * })
     * 
     */
    create<T extends bitacoraCreateArgs>(args: SelectSubset<T, bitacoraCreateArgs<ExtArgs>>): Prisma__bitacoraClient<$Result.GetResult<Prisma.$bitacoraPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Bitacoras.
     * @param {bitacoraCreateManyArgs} args - Arguments to create many Bitacoras.
     * @example
     * // Create many Bitacoras
     * const bitacora = await prisma.bitacora.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends bitacoraCreateManyArgs>(args?: SelectSubset<T, bitacoraCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Bitacora.
     * @param {bitacoraDeleteArgs} args - Arguments to delete one Bitacora.
     * @example
     * // Delete one Bitacora
     * const Bitacora = await prisma.bitacora.delete({
     *   where: {
     *     // ... filter to delete one Bitacora
     *   }
     * })
     * 
     */
    delete<T extends bitacoraDeleteArgs>(args: SelectSubset<T, bitacoraDeleteArgs<ExtArgs>>): Prisma__bitacoraClient<$Result.GetResult<Prisma.$bitacoraPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Bitacora.
     * @param {bitacoraUpdateArgs} args - Arguments to update one Bitacora.
     * @example
     * // Update one Bitacora
     * const bitacora = await prisma.bitacora.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends bitacoraUpdateArgs>(args: SelectSubset<T, bitacoraUpdateArgs<ExtArgs>>): Prisma__bitacoraClient<$Result.GetResult<Prisma.$bitacoraPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Bitacoras.
     * @param {bitacoraDeleteManyArgs} args - Arguments to filter Bitacoras to delete.
     * @example
     * // Delete a few Bitacoras
     * const { count } = await prisma.bitacora.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends bitacoraDeleteManyArgs>(args?: SelectSubset<T, bitacoraDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bitacoras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bitacoraUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bitacoras
     * const bitacora = await prisma.bitacora.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends bitacoraUpdateManyArgs>(args: SelectSubset<T, bitacoraUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bitacora.
     * @param {bitacoraUpsertArgs} args - Arguments to update or create a Bitacora.
     * @example
     * // Update or create a Bitacora
     * const bitacora = await prisma.bitacora.upsert({
     *   create: {
     *     // ... data to create a Bitacora
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bitacora we want to update
     *   }
     * })
     */
    upsert<T extends bitacoraUpsertArgs>(args: SelectSubset<T, bitacoraUpsertArgs<ExtArgs>>): Prisma__bitacoraClient<$Result.GetResult<Prisma.$bitacoraPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Bitacoras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bitacoraCountArgs} args - Arguments to filter Bitacoras to count.
     * @example
     * // Count the number of Bitacoras
     * const count = await prisma.bitacora.count({
     *   where: {
     *     // ... the filter for the Bitacoras we want to count
     *   }
     * })
    **/
    count<T extends bitacoraCountArgs>(
      args?: Subset<T, bitacoraCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BitacoraCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bitacora.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BitacoraAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BitacoraAggregateArgs>(args: Subset<T, BitacoraAggregateArgs>): Prisma.PrismaPromise<GetBitacoraAggregateType<T>>

    /**
     * Group by Bitacora.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bitacoraGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends bitacoraGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: bitacoraGroupByArgs['orderBy'] }
        : { orderBy?: bitacoraGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, bitacoraGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBitacoraGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the bitacora model
   */
  readonly fields: bitacoraFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for bitacora.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__bitacoraClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the bitacora model
   */
  interface bitacoraFieldRefs {
    readonly id: FieldRef<"bitacora", 'Int'>
    readonly usuario_id: FieldRef<"bitacora", 'Int'>
    readonly rol: FieldRef<"bitacora", 'String'>
    readonly accion: FieldRef<"bitacora", 'String'>
    readonly ip: FieldRef<"bitacora", 'String'>
    readonly descripcion: FieldRef<"bitacora", 'String'>
    readonly fecha_inicio: FieldRef<"bitacora", 'DateTime'>
    readonly fecha_act: FieldRef<"bitacora", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * bitacora findUnique
   */
  export type bitacoraFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bitacora
     */
    select?: bitacoraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bitacora
     */
    omit?: bitacoraOmit<ExtArgs> | null
    /**
     * Filter, which bitacora to fetch.
     */
    where: bitacoraWhereUniqueInput
  }

  /**
   * bitacora findUniqueOrThrow
   */
  export type bitacoraFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bitacora
     */
    select?: bitacoraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bitacora
     */
    omit?: bitacoraOmit<ExtArgs> | null
    /**
     * Filter, which bitacora to fetch.
     */
    where: bitacoraWhereUniqueInput
  }

  /**
   * bitacora findFirst
   */
  export type bitacoraFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bitacora
     */
    select?: bitacoraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bitacora
     */
    omit?: bitacoraOmit<ExtArgs> | null
    /**
     * Filter, which bitacora to fetch.
     */
    where?: bitacoraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bitacoras to fetch.
     */
    orderBy?: bitacoraOrderByWithRelationInput | bitacoraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bitacoras.
     */
    cursor?: bitacoraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bitacoras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bitacoras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bitacoras.
     */
    distinct?: BitacoraScalarFieldEnum | BitacoraScalarFieldEnum[]
  }

  /**
   * bitacora findFirstOrThrow
   */
  export type bitacoraFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bitacora
     */
    select?: bitacoraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bitacora
     */
    omit?: bitacoraOmit<ExtArgs> | null
    /**
     * Filter, which bitacora to fetch.
     */
    where?: bitacoraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bitacoras to fetch.
     */
    orderBy?: bitacoraOrderByWithRelationInput | bitacoraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bitacoras.
     */
    cursor?: bitacoraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bitacoras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bitacoras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bitacoras.
     */
    distinct?: BitacoraScalarFieldEnum | BitacoraScalarFieldEnum[]
  }

  /**
   * bitacora findMany
   */
  export type bitacoraFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bitacora
     */
    select?: bitacoraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bitacora
     */
    omit?: bitacoraOmit<ExtArgs> | null
    /**
     * Filter, which bitacoras to fetch.
     */
    where?: bitacoraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bitacoras to fetch.
     */
    orderBy?: bitacoraOrderByWithRelationInput | bitacoraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing bitacoras.
     */
    cursor?: bitacoraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bitacoras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bitacoras.
     */
    skip?: number
    distinct?: BitacoraScalarFieldEnum | BitacoraScalarFieldEnum[]
  }

  /**
   * bitacora create
   */
  export type bitacoraCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bitacora
     */
    select?: bitacoraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bitacora
     */
    omit?: bitacoraOmit<ExtArgs> | null
    /**
     * The data needed to create a bitacora.
     */
    data?: XOR<bitacoraCreateInput, bitacoraUncheckedCreateInput>
  }

  /**
   * bitacora createMany
   */
  export type bitacoraCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many bitacoras.
     */
    data: bitacoraCreateManyInput | bitacoraCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * bitacora update
   */
  export type bitacoraUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bitacora
     */
    select?: bitacoraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bitacora
     */
    omit?: bitacoraOmit<ExtArgs> | null
    /**
     * The data needed to update a bitacora.
     */
    data: XOR<bitacoraUpdateInput, bitacoraUncheckedUpdateInput>
    /**
     * Choose, which bitacora to update.
     */
    where: bitacoraWhereUniqueInput
  }

  /**
   * bitacora updateMany
   */
  export type bitacoraUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update bitacoras.
     */
    data: XOR<bitacoraUpdateManyMutationInput, bitacoraUncheckedUpdateManyInput>
    /**
     * Filter which bitacoras to update
     */
    where?: bitacoraWhereInput
    /**
     * Limit how many bitacoras to update.
     */
    limit?: number
  }

  /**
   * bitacora upsert
   */
  export type bitacoraUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bitacora
     */
    select?: bitacoraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bitacora
     */
    omit?: bitacoraOmit<ExtArgs> | null
    /**
     * The filter to search for the bitacora to update in case it exists.
     */
    where: bitacoraWhereUniqueInput
    /**
     * In case the bitacora found by the `where` argument doesn't exist, create a new bitacora with this data.
     */
    create: XOR<bitacoraCreateInput, bitacoraUncheckedCreateInput>
    /**
     * In case the bitacora was found with the provided `where` argument, update it with this data.
     */
    update: XOR<bitacoraUpdateInput, bitacoraUncheckedUpdateInput>
  }

  /**
   * bitacora delete
   */
  export type bitacoraDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bitacora
     */
    select?: bitacoraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bitacora
     */
    omit?: bitacoraOmit<ExtArgs> | null
    /**
     * Filter which bitacora to delete.
     */
    where: bitacoraWhereUniqueInput
  }

  /**
   * bitacora deleteMany
   */
  export type bitacoraDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bitacoras to delete
     */
    where?: bitacoraWhereInput
    /**
     * Limit how many bitacoras to delete.
     */
    limit?: number
  }

  /**
   * bitacora without action
   */
  export type bitacoraDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bitacora
     */
    select?: bitacoraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bitacora
     */
    omit?: bitacoraOmit<ExtArgs> | null
  }


  /**
   * Model departamentos
   */

  export type AggregateDepartamentos = {
    _count: DepartamentosCountAggregateOutputType | null
    _avg: DepartamentosAvgAggregateOutputType | null
    _sum: DepartamentosSumAggregateOutputType | null
    _min: DepartamentosMinAggregateOutputType | null
    _max: DepartamentosMaxAggregateOutputType | null
  }

  export type DepartamentosAvgAggregateOutputType = {
    id: number | null
  }

  export type DepartamentosSumAggregateOutputType = {
    id: number | null
  }

  export type DepartamentosMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    descripcion: string | null
    activo: boolean | null
  }

  export type DepartamentosMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    descripcion: string | null
    activo: boolean | null
  }

  export type DepartamentosCountAggregateOutputType = {
    id: number
    nombre: number
    descripcion: number
    activo: number
    _all: number
  }


  export type DepartamentosAvgAggregateInputType = {
    id?: true
  }

  export type DepartamentosSumAggregateInputType = {
    id?: true
  }

  export type DepartamentosMinAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    activo?: true
  }

  export type DepartamentosMaxAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    activo?: true
  }

  export type DepartamentosCountAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    activo?: true
    _all?: true
  }

  export type DepartamentosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which departamentos to aggregate.
     */
    where?: departamentosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of departamentos to fetch.
     */
    orderBy?: departamentosOrderByWithRelationInput | departamentosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: departamentosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` departamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` departamentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned departamentos
    **/
    _count?: true | DepartamentosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DepartamentosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DepartamentosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepartamentosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepartamentosMaxAggregateInputType
  }

  export type GetDepartamentosAggregateType<T extends DepartamentosAggregateArgs> = {
        [P in keyof T & keyof AggregateDepartamentos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepartamentos[P]>
      : GetScalarType<T[P], AggregateDepartamentos[P]>
  }




  export type departamentosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: departamentosWhereInput
    orderBy?: departamentosOrderByWithAggregationInput | departamentosOrderByWithAggregationInput[]
    by: DepartamentosScalarFieldEnum[] | DepartamentosScalarFieldEnum
    having?: departamentosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepartamentosCountAggregateInputType | true
    _avg?: DepartamentosAvgAggregateInputType
    _sum?: DepartamentosSumAggregateInputType
    _min?: DepartamentosMinAggregateInputType
    _max?: DepartamentosMaxAggregateInputType
  }

  export type DepartamentosGroupByOutputType = {
    id: number
    nombre: string | null
    descripcion: string | null
    activo: boolean | null
    _count: DepartamentosCountAggregateOutputType | null
    _avg: DepartamentosAvgAggregateOutputType | null
    _sum: DepartamentosSumAggregateOutputType | null
    _min: DepartamentosMinAggregateOutputType | null
    _max: DepartamentosMaxAggregateOutputType | null
  }

  type GetDepartamentosGroupByPayload<T extends departamentosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepartamentosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepartamentosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepartamentosGroupByOutputType[P]>
            : GetScalarType<T[P], DepartamentosGroupByOutputType[P]>
        }
      >
    >


  export type departamentosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    activo?: boolean
  }, ExtArgs["result"]["departamentos"]>



  export type departamentosSelectScalar = {
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    activo?: boolean
  }

  export type departamentosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nombre" | "descripcion" | "activo", ExtArgs["result"]["departamentos"]>

  export type $departamentosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "departamentos"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre: string | null
      descripcion: string | null
      activo: boolean | null
    }, ExtArgs["result"]["departamentos"]>
    composites: {}
  }

  type departamentosGetPayload<S extends boolean | null | undefined | departamentosDefaultArgs> = $Result.GetResult<Prisma.$departamentosPayload, S>

  type departamentosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<departamentosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DepartamentosCountAggregateInputType | true
    }

  export interface departamentosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['departamentos'], meta: { name: 'departamentos' } }
    /**
     * Find zero or one Departamentos that matches the filter.
     * @param {departamentosFindUniqueArgs} args - Arguments to find a Departamentos
     * @example
     * // Get one Departamentos
     * const departamentos = await prisma.departamentos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends departamentosFindUniqueArgs>(args: SelectSubset<T, departamentosFindUniqueArgs<ExtArgs>>): Prisma__departamentosClient<$Result.GetResult<Prisma.$departamentosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Departamentos that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {departamentosFindUniqueOrThrowArgs} args - Arguments to find a Departamentos
     * @example
     * // Get one Departamentos
     * const departamentos = await prisma.departamentos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends departamentosFindUniqueOrThrowArgs>(args: SelectSubset<T, departamentosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__departamentosClient<$Result.GetResult<Prisma.$departamentosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Departamentos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {departamentosFindFirstArgs} args - Arguments to find a Departamentos
     * @example
     * // Get one Departamentos
     * const departamentos = await prisma.departamentos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends departamentosFindFirstArgs>(args?: SelectSubset<T, departamentosFindFirstArgs<ExtArgs>>): Prisma__departamentosClient<$Result.GetResult<Prisma.$departamentosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Departamentos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {departamentosFindFirstOrThrowArgs} args - Arguments to find a Departamentos
     * @example
     * // Get one Departamentos
     * const departamentos = await prisma.departamentos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends departamentosFindFirstOrThrowArgs>(args?: SelectSubset<T, departamentosFindFirstOrThrowArgs<ExtArgs>>): Prisma__departamentosClient<$Result.GetResult<Prisma.$departamentosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Departamentos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {departamentosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Departamentos
     * const departamentos = await prisma.departamentos.findMany()
     * 
     * // Get first 10 Departamentos
     * const departamentos = await prisma.departamentos.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const departamentosWithIdOnly = await prisma.departamentos.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends departamentosFindManyArgs>(args?: SelectSubset<T, departamentosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$departamentosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Departamentos.
     * @param {departamentosCreateArgs} args - Arguments to create a Departamentos.
     * @example
     * // Create one Departamentos
     * const Departamentos = await prisma.departamentos.create({
     *   data: {
     *     // ... data to create a Departamentos
     *   }
     * })
     * 
     */
    create<T extends departamentosCreateArgs>(args: SelectSubset<T, departamentosCreateArgs<ExtArgs>>): Prisma__departamentosClient<$Result.GetResult<Prisma.$departamentosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Departamentos.
     * @param {departamentosCreateManyArgs} args - Arguments to create many Departamentos.
     * @example
     * // Create many Departamentos
     * const departamentos = await prisma.departamentos.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends departamentosCreateManyArgs>(args?: SelectSubset<T, departamentosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Departamentos.
     * @param {departamentosDeleteArgs} args - Arguments to delete one Departamentos.
     * @example
     * // Delete one Departamentos
     * const Departamentos = await prisma.departamentos.delete({
     *   where: {
     *     // ... filter to delete one Departamentos
     *   }
     * })
     * 
     */
    delete<T extends departamentosDeleteArgs>(args: SelectSubset<T, departamentosDeleteArgs<ExtArgs>>): Prisma__departamentosClient<$Result.GetResult<Prisma.$departamentosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Departamentos.
     * @param {departamentosUpdateArgs} args - Arguments to update one Departamentos.
     * @example
     * // Update one Departamentos
     * const departamentos = await prisma.departamentos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends departamentosUpdateArgs>(args: SelectSubset<T, departamentosUpdateArgs<ExtArgs>>): Prisma__departamentosClient<$Result.GetResult<Prisma.$departamentosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Departamentos.
     * @param {departamentosDeleteManyArgs} args - Arguments to filter Departamentos to delete.
     * @example
     * // Delete a few Departamentos
     * const { count } = await prisma.departamentos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends departamentosDeleteManyArgs>(args?: SelectSubset<T, departamentosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departamentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {departamentosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Departamentos
     * const departamentos = await prisma.departamentos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends departamentosUpdateManyArgs>(args: SelectSubset<T, departamentosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Departamentos.
     * @param {departamentosUpsertArgs} args - Arguments to update or create a Departamentos.
     * @example
     * // Update or create a Departamentos
     * const departamentos = await prisma.departamentos.upsert({
     *   create: {
     *     // ... data to create a Departamentos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Departamentos we want to update
     *   }
     * })
     */
    upsert<T extends departamentosUpsertArgs>(args: SelectSubset<T, departamentosUpsertArgs<ExtArgs>>): Prisma__departamentosClient<$Result.GetResult<Prisma.$departamentosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Departamentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {departamentosCountArgs} args - Arguments to filter Departamentos to count.
     * @example
     * // Count the number of Departamentos
     * const count = await prisma.departamentos.count({
     *   where: {
     *     // ... the filter for the Departamentos we want to count
     *   }
     * })
    **/
    count<T extends departamentosCountArgs>(
      args?: Subset<T, departamentosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepartamentosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Departamentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartamentosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepartamentosAggregateArgs>(args: Subset<T, DepartamentosAggregateArgs>): Prisma.PrismaPromise<GetDepartamentosAggregateType<T>>

    /**
     * Group by Departamentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {departamentosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends departamentosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: departamentosGroupByArgs['orderBy'] }
        : { orderBy?: departamentosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, departamentosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepartamentosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the departamentos model
   */
  readonly fields: departamentosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for departamentos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__departamentosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the departamentos model
   */
  interface departamentosFieldRefs {
    readonly id: FieldRef<"departamentos", 'Int'>
    readonly nombre: FieldRef<"departamentos", 'String'>
    readonly descripcion: FieldRef<"departamentos", 'String'>
    readonly activo: FieldRef<"departamentos", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * departamentos findUnique
   */
  export type departamentosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the departamentos
     */
    select?: departamentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the departamentos
     */
    omit?: departamentosOmit<ExtArgs> | null
    /**
     * Filter, which departamentos to fetch.
     */
    where: departamentosWhereUniqueInput
  }

  /**
   * departamentos findUniqueOrThrow
   */
  export type departamentosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the departamentos
     */
    select?: departamentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the departamentos
     */
    omit?: departamentosOmit<ExtArgs> | null
    /**
     * Filter, which departamentos to fetch.
     */
    where: departamentosWhereUniqueInput
  }

  /**
   * departamentos findFirst
   */
  export type departamentosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the departamentos
     */
    select?: departamentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the departamentos
     */
    omit?: departamentosOmit<ExtArgs> | null
    /**
     * Filter, which departamentos to fetch.
     */
    where?: departamentosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of departamentos to fetch.
     */
    orderBy?: departamentosOrderByWithRelationInput | departamentosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for departamentos.
     */
    cursor?: departamentosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` departamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` departamentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of departamentos.
     */
    distinct?: DepartamentosScalarFieldEnum | DepartamentosScalarFieldEnum[]
  }

  /**
   * departamentos findFirstOrThrow
   */
  export type departamentosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the departamentos
     */
    select?: departamentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the departamentos
     */
    omit?: departamentosOmit<ExtArgs> | null
    /**
     * Filter, which departamentos to fetch.
     */
    where?: departamentosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of departamentos to fetch.
     */
    orderBy?: departamentosOrderByWithRelationInput | departamentosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for departamentos.
     */
    cursor?: departamentosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` departamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` departamentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of departamentos.
     */
    distinct?: DepartamentosScalarFieldEnum | DepartamentosScalarFieldEnum[]
  }

  /**
   * departamentos findMany
   */
  export type departamentosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the departamentos
     */
    select?: departamentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the departamentos
     */
    omit?: departamentosOmit<ExtArgs> | null
    /**
     * Filter, which departamentos to fetch.
     */
    where?: departamentosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of departamentos to fetch.
     */
    orderBy?: departamentosOrderByWithRelationInput | departamentosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing departamentos.
     */
    cursor?: departamentosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` departamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` departamentos.
     */
    skip?: number
    distinct?: DepartamentosScalarFieldEnum | DepartamentosScalarFieldEnum[]
  }

  /**
   * departamentos create
   */
  export type departamentosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the departamentos
     */
    select?: departamentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the departamentos
     */
    omit?: departamentosOmit<ExtArgs> | null
    /**
     * The data needed to create a departamentos.
     */
    data?: XOR<departamentosCreateInput, departamentosUncheckedCreateInput>
  }

  /**
   * departamentos createMany
   */
  export type departamentosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many departamentos.
     */
    data: departamentosCreateManyInput | departamentosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * departamentos update
   */
  export type departamentosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the departamentos
     */
    select?: departamentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the departamentos
     */
    omit?: departamentosOmit<ExtArgs> | null
    /**
     * The data needed to update a departamentos.
     */
    data: XOR<departamentosUpdateInput, departamentosUncheckedUpdateInput>
    /**
     * Choose, which departamentos to update.
     */
    where: departamentosWhereUniqueInput
  }

  /**
   * departamentos updateMany
   */
  export type departamentosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update departamentos.
     */
    data: XOR<departamentosUpdateManyMutationInput, departamentosUncheckedUpdateManyInput>
    /**
     * Filter which departamentos to update
     */
    where?: departamentosWhereInput
    /**
     * Limit how many departamentos to update.
     */
    limit?: number
  }

  /**
   * departamentos upsert
   */
  export type departamentosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the departamentos
     */
    select?: departamentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the departamentos
     */
    omit?: departamentosOmit<ExtArgs> | null
    /**
     * The filter to search for the departamentos to update in case it exists.
     */
    where: departamentosWhereUniqueInput
    /**
     * In case the departamentos found by the `where` argument doesn't exist, create a new departamentos with this data.
     */
    create: XOR<departamentosCreateInput, departamentosUncheckedCreateInput>
    /**
     * In case the departamentos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<departamentosUpdateInput, departamentosUncheckedUpdateInput>
  }

  /**
   * departamentos delete
   */
  export type departamentosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the departamentos
     */
    select?: departamentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the departamentos
     */
    omit?: departamentosOmit<ExtArgs> | null
    /**
     * Filter which departamentos to delete.
     */
    where: departamentosWhereUniqueInput
  }

  /**
   * departamentos deleteMany
   */
  export type departamentosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which departamentos to delete
     */
    where?: departamentosWhereInput
    /**
     * Limit how many departamentos to delete.
     */
    limit?: number
  }

  /**
   * departamentos without action
   */
  export type departamentosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the departamentos
     */
    select?: departamentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the departamentos
     */
    omit?: departamentosOmit<ExtArgs> | null
  }


  /**
   * Model documentos
   */

  export type AggregateDocumentos = {
    _count: DocumentosCountAggregateOutputType | null
    _avg: DocumentosAvgAggregateOutputType | null
    _sum: DocumentosSumAggregateOutputType | null
    _min: DocumentosMinAggregateOutputType | null
    _max: DocumentosMaxAggregateOutputType | null
  }

  export type DocumentosAvgAggregateOutputType = {
    id: number | null
    tipos_documentos_id: number | null
    usuarios_id: number | null
  }

  export type DocumentosSumAggregateOutputType = {
    id: number | null
    tipos_documentos_id: number | null
    usuarios_id: number | null
  }

  export type DocumentosMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    descripcion: string | null
    mime: string | null
    ruta: string | null
    tipos_documentos_id: number | null
    usuarios_id: number | null
    fecha_subida: Date | null
  }

  export type DocumentosMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    descripcion: string | null
    mime: string | null
    ruta: string | null
    tipos_documentos_id: number | null
    usuarios_id: number | null
    fecha_subida: Date | null
  }

  export type DocumentosCountAggregateOutputType = {
    id: number
    nombre: number
    descripcion: number
    mime: number
    ruta: number
    tipos_documentos_id: number
    usuarios_id: number
    fecha_subida: number
    _all: number
  }


  export type DocumentosAvgAggregateInputType = {
    id?: true
    tipos_documentos_id?: true
    usuarios_id?: true
  }

  export type DocumentosSumAggregateInputType = {
    id?: true
    tipos_documentos_id?: true
    usuarios_id?: true
  }

  export type DocumentosMinAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    mime?: true
    ruta?: true
    tipos_documentos_id?: true
    usuarios_id?: true
    fecha_subida?: true
  }

  export type DocumentosMaxAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    mime?: true
    ruta?: true
    tipos_documentos_id?: true
    usuarios_id?: true
    fecha_subida?: true
  }

  export type DocumentosCountAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    mime?: true
    ruta?: true
    tipos_documentos_id?: true
    usuarios_id?: true
    fecha_subida?: true
    _all?: true
  }

  export type DocumentosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which documentos to aggregate.
     */
    where?: documentosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of documentos to fetch.
     */
    orderBy?: documentosOrderByWithRelationInput | documentosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: documentosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` documentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` documentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned documentos
    **/
    _count?: true | DocumentosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DocumentosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DocumentosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentosMaxAggregateInputType
  }

  export type GetDocumentosAggregateType<T extends DocumentosAggregateArgs> = {
        [P in keyof T & keyof AggregateDocumentos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocumentos[P]>
      : GetScalarType<T[P], AggregateDocumentos[P]>
  }




  export type documentosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: documentosWhereInput
    orderBy?: documentosOrderByWithAggregationInput | documentosOrderByWithAggregationInput[]
    by: DocumentosScalarFieldEnum[] | DocumentosScalarFieldEnum
    having?: documentosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentosCountAggregateInputType | true
    _avg?: DocumentosAvgAggregateInputType
    _sum?: DocumentosSumAggregateInputType
    _min?: DocumentosMinAggregateInputType
    _max?: DocumentosMaxAggregateInputType
  }

  export type DocumentosGroupByOutputType = {
    id: number
    nombre: string | null
    descripcion: string | null
    mime: string | null
    ruta: string | null
    tipos_documentos_id: number | null
    usuarios_id: number | null
    fecha_subida: Date | null
    _count: DocumentosCountAggregateOutputType | null
    _avg: DocumentosAvgAggregateOutputType | null
    _sum: DocumentosSumAggregateOutputType | null
    _min: DocumentosMinAggregateOutputType | null
    _max: DocumentosMaxAggregateOutputType | null
  }

  type GetDocumentosGroupByPayload<T extends documentosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentosGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentosGroupByOutputType[P]>
        }
      >
    >


  export type documentosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    mime?: boolean
    ruta?: boolean
    tipos_documentos_id?: boolean
    usuarios_id?: boolean
    fecha_subida?: boolean
    tipos_documentos?: boolean | documentos$tipos_documentosArgs<ExtArgs>
    usuarios?: boolean | documentos$usuariosArgs<ExtArgs>
  }, ExtArgs["result"]["documentos"]>



  export type documentosSelectScalar = {
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    mime?: boolean
    ruta?: boolean
    tipos_documentos_id?: boolean
    usuarios_id?: boolean
    fecha_subida?: boolean
  }

  export type documentosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nombre" | "descripcion" | "mime" | "ruta" | "tipos_documentos_id" | "usuarios_id" | "fecha_subida", ExtArgs["result"]["documentos"]>
  export type documentosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tipos_documentos?: boolean | documentos$tipos_documentosArgs<ExtArgs>
    usuarios?: boolean | documentos$usuariosArgs<ExtArgs>
  }

  export type $documentosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "documentos"
    objects: {
      tipos_documentos: Prisma.$tipos_documentosPayload<ExtArgs> | null
      usuarios: Prisma.$usuariosPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre: string | null
      descripcion: string | null
      mime: string | null
      ruta: string | null
      tipos_documentos_id: number | null
      usuarios_id: number | null
      fecha_subida: Date | null
    }, ExtArgs["result"]["documentos"]>
    composites: {}
  }

  type documentosGetPayload<S extends boolean | null | undefined | documentosDefaultArgs> = $Result.GetResult<Prisma.$documentosPayload, S>

  type documentosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<documentosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DocumentosCountAggregateInputType | true
    }

  export interface documentosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['documentos'], meta: { name: 'documentos' } }
    /**
     * Find zero or one Documentos that matches the filter.
     * @param {documentosFindUniqueArgs} args - Arguments to find a Documentos
     * @example
     * // Get one Documentos
     * const documentos = await prisma.documentos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends documentosFindUniqueArgs>(args: SelectSubset<T, documentosFindUniqueArgs<ExtArgs>>): Prisma__documentosClient<$Result.GetResult<Prisma.$documentosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Documentos that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {documentosFindUniqueOrThrowArgs} args - Arguments to find a Documentos
     * @example
     * // Get one Documentos
     * const documentos = await prisma.documentos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends documentosFindUniqueOrThrowArgs>(args: SelectSubset<T, documentosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__documentosClient<$Result.GetResult<Prisma.$documentosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Documentos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {documentosFindFirstArgs} args - Arguments to find a Documentos
     * @example
     * // Get one Documentos
     * const documentos = await prisma.documentos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends documentosFindFirstArgs>(args?: SelectSubset<T, documentosFindFirstArgs<ExtArgs>>): Prisma__documentosClient<$Result.GetResult<Prisma.$documentosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Documentos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {documentosFindFirstOrThrowArgs} args - Arguments to find a Documentos
     * @example
     * // Get one Documentos
     * const documentos = await prisma.documentos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends documentosFindFirstOrThrowArgs>(args?: SelectSubset<T, documentosFindFirstOrThrowArgs<ExtArgs>>): Prisma__documentosClient<$Result.GetResult<Prisma.$documentosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Documentos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {documentosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documentos
     * const documentos = await prisma.documentos.findMany()
     * 
     * // Get first 10 Documentos
     * const documentos = await prisma.documentos.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentosWithIdOnly = await prisma.documentos.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends documentosFindManyArgs>(args?: SelectSubset<T, documentosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$documentosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Documentos.
     * @param {documentosCreateArgs} args - Arguments to create a Documentos.
     * @example
     * // Create one Documentos
     * const Documentos = await prisma.documentos.create({
     *   data: {
     *     // ... data to create a Documentos
     *   }
     * })
     * 
     */
    create<T extends documentosCreateArgs>(args: SelectSubset<T, documentosCreateArgs<ExtArgs>>): Prisma__documentosClient<$Result.GetResult<Prisma.$documentosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Documentos.
     * @param {documentosCreateManyArgs} args - Arguments to create many Documentos.
     * @example
     * // Create many Documentos
     * const documentos = await prisma.documentos.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends documentosCreateManyArgs>(args?: SelectSubset<T, documentosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Documentos.
     * @param {documentosDeleteArgs} args - Arguments to delete one Documentos.
     * @example
     * // Delete one Documentos
     * const Documentos = await prisma.documentos.delete({
     *   where: {
     *     // ... filter to delete one Documentos
     *   }
     * })
     * 
     */
    delete<T extends documentosDeleteArgs>(args: SelectSubset<T, documentosDeleteArgs<ExtArgs>>): Prisma__documentosClient<$Result.GetResult<Prisma.$documentosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Documentos.
     * @param {documentosUpdateArgs} args - Arguments to update one Documentos.
     * @example
     * // Update one Documentos
     * const documentos = await prisma.documentos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends documentosUpdateArgs>(args: SelectSubset<T, documentosUpdateArgs<ExtArgs>>): Prisma__documentosClient<$Result.GetResult<Prisma.$documentosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Documentos.
     * @param {documentosDeleteManyArgs} args - Arguments to filter Documentos to delete.
     * @example
     * // Delete a few Documentos
     * const { count } = await prisma.documentos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends documentosDeleteManyArgs>(args?: SelectSubset<T, documentosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {documentosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documentos
     * const documentos = await prisma.documentos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends documentosUpdateManyArgs>(args: SelectSubset<T, documentosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Documentos.
     * @param {documentosUpsertArgs} args - Arguments to update or create a Documentos.
     * @example
     * // Update or create a Documentos
     * const documentos = await prisma.documentos.upsert({
     *   create: {
     *     // ... data to create a Documentos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Documentos we want to update
     *   }
     * })
     */
    upsert<T extends documentosUpsertArgs>(args: SelectSubset<T, documentosUpsertArgs<ExtArgs>>): Prisma__documentosClient<$Result.GetResult<Prisma.$documentosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Documentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {documentosCountArgs} args - Arguments to filter Documentos to count.
     * @example
     * // Count the number of Documentos
     * const count = await prisma.documentos.count({
     *   where: {
     *     // ... the filter for the Documentos we want to count
     *   }
     * })
    **/
    count<T extends documentosCountArgs>(
      args?: Subset<T, documentosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Documentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentosAggregateArgs>(args: Subset<T, DocumentosAggregateArgs>): Prisma.PrismaPromise<GetDocumentosAggregateType<T>>

    /**
     * Group by Documentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {documentosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends documentosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: documentosGroupByArgs['orderBy'] }
        : { orderBy?: documentosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, documentosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the documentos model
   */
  readonly fields: documentosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for documentos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__documentosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tipos_documentos<T extends documentos$tipos_documentosArgs<ExtArgs> = {}>(args?: Subset<T, documentos$tipos_documentosArgs<ExtArgs>>): Prisma__tipos_documentosClient<$Result.GetResult<Prisma.$tipos_documentosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    usuarios<T extends documentos$usuariosArgs<ExtArgs> = {}>(args?: Subset<T, documentos$usuariosArgs<ExtArgs>>): Prisma__usuariosClient<$Result.GetResult<Prisma.$usuariosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the documentos model
   */
  interface documentosFieldRefs {
    readonly id: FieldRef<"documentos", 'Int'>
    readonly nombre: FieldRef<"documentos", 'String'>
    readonly descripcion: FieldRef<"documentos", 'String'>
    readonly mime: FieldRef<"documentos", 'String'>
    readonly ruta: FieldRef<"documentos", 'String'>
    readonly tipos_documentos_id: FieldRef<"documentos", 'Int'>
    readonly usuarios_id: FieldRef<"documentos", 'Int'>
    readonly fecha_subida: FieldRef<"documentos", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * documentos findUnique
   */
  export type documentosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documentos
     */
    select?: documentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the documentos
     */
    omit?: documentosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: documentosInclude<ExtArgs> | null
    /**
     * Filter, which documentos to fetch.
     */
    where: documentosWhereUniqueInput
  }

  /**
   * documentos findUniqueOrThrow
   */
  export type documentosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documentos
     */
    select?: documentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the documentos
     */
    omit?: documentosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: documentosInclude<ExtArgs> | null
    /**
     * Filter, which documentos to fetch.
     */
    where: documentosWhereUniqueInput
  }

  /**
   * documentos findFirst
   */
  export type documentosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documentos
     */
    select?: documentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the documentos
     */
    omit?: documentosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: documentosInclude<ExtArgs> | null
    /**
     * Filter, which documentos to fetch.
     */
    where?: documentosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of documentos to fetch.
     */
    orderBy?: documentosOrderByWithRelationInput | documentosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for documentos.
     */
    cursor?: documentosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` documentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` documentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of documentos.
     */
    distinct?: DocumentosScalarFieldEnum | DocumentosScalarFieldEnum[]
  }

  /**
   * documentos findFirstOrThrow
   */
  export type documentosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documentos
     */
    select?: documentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the documentos
     */
    omit?: documentosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: documentosInclude<ExtArgs> | null
    /**
     * Filter, which documentos to fetch.
     */
    where?: documentosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of documentos to fetch.
     */
    orderBy?: documentosOrderByWithRelationInput | documentosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for documentos.
     */
    cursor?: documentosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` documentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` documentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of documentos.
     */
    distinct?: DocumentosScalarFieldEnum | DocumentosScalarFieldEnum[]
  }

  /**
   * documentos findMany
   */
  export type documentosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documentos
     */
    select?: documentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the documentos
     */
    omit?: documentosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: documentosInclude<ExtArgs> | null
    /**
     * Filter, which documentos to fetch.
     */
    where?: documentosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of documentos to fetch.
     */
    orderBy?: documentosOrderByWithRelationInput | documentosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing documentos.
     */
    cursor?: documentosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` documentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` documentos.
     */
    skip?: number
    distinct?: DocumentosScalarFieldEnum | DocumentosScalarFieldEnum[]
  }

  /**
   * documentos create
   */
  export type documentosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documentos
     */
    select?: documentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the documentos
     */
    omit?: documentosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: documentosInclude<ExtArgs> | null
    /**
     * The data needed to create a documentos.
     */
    data?: XOR<documentosCreateInput, documentosUncheckedCreateInput>
  }

  /**
   * documentos createMany
   */
  export type documentosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many documentos.
     */
    data: documentosCreateManyInput | documentosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * documentos update
   */
  export type documentosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documentos
     */
    select?: documentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the documentos
     */
    omit?: documentosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: documentosInclude<ExtArgs> | null
    /**
     * The data needed to update a documentos.
     */
    data: XOR<documentosUpdateInput, documentosUncheckedUpdateInput>
    /**
     * Choose, which documentos to update.
     */
    where: documentosWhereUniqueInput
  }

  /**
   * documentos updateMany
   */
  export type documentosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update documentos.
     */
    data: XOR<documentosUpdateManyMutationInput, documentosUncheckedUpdateManyInput>
    /**
     * Filter which documentos to update
     */
    where?: documentosWhereInput
    /**
     * Limit how many documentos to update.
     */
    limit?: number
  }

  /**
   * documentos upsert
   */
  export type documentosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documentos
     */
    select?: documentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the documentos
     */
    omit?: documentosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: documentosInclude<ExtArgs> | null
    /**
     * The filter to search for the documentos to update in case it exists.
     */
    where: documentosWhereUniqueInput
    /**
     * In case the documentos found by the `where` argument doesn't exist, create a new documentos with this data.
     */
    create: XOR<documentosCreateInput, documentosUncheckedCreateInput>
    /**
     * In case the documentos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<documentosUpdateInput, documentosUncheckedUpdateInput>
  }

  /**
   * documentos delete
   */
  export type documentosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documentos
     */
    select?: documentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the documentos
     */
    omit?: documentosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: documentosInclude<ExtArgs> | null
    /**
     * Filter which documentos to delete.
     */
    where: documentosWhereUniqueInput
  }

  /**
   * documentos deleteMany
   */
  export type documentosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which documentos to delete
     */
    where?: documentosWhereInput
    /**
     * Limit how many documentos to delete.
     */
    limit?: number
  }

  /**
   * documentos.tipos_documentos
   */
  export type documentos$tipos_documentosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipos_documentos
     */
    select?: tipos_documentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipos_documentos
     */
    omit?: tipos_documentosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipos_documentosInclude<ExtArgs> | null
    where?: tipos_documentosWhereInput
  }

  /**
   * documentos.usuarios
   */
  export type documentos$usuariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuarios
     */
    select?: usuariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuarios
     */
    omit?: usuariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosInclude<ExtArgs> | null
    where?: usuariosWhereInput
  }

  /**
   * documentos without action
   */
  export type documentosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documentos
     */
    select?: documentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the documentos
     */
    omit?: documentosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: documentosInclude<ExtArgs> | null
  }


  /**
   * Model periodos
   */

  export type AggregatePeriodos = {
    _count: PeriodosCountAggregateOutputType | null
    _avg: PeriodosAvgAggregateOutputType | null
    _sum: PeriodosSumAggregateOutputType | null
    _min: PeriodosMinAggregateOutputType | null
    _max: PeriodosMaxAggregateOutputType | null
  }

  export type PeriodosAvgAggregateOutputType = {
    id: number | null
  }

  export type PeriodosSumAggregateOutputType = {
    id: number | null
  }

  export type PeriodosMinAggregateOutputType = {
    id: number | null
    periodo: string | null
    fecha_inicio: Date | null
    fecha_final: Date | null
    activo: boolean | null
  }

  export type PeriodosMaxAggregateOutputType = {
    id: number | null
    periodo: string | null
    fecha_inicio: Date | null
    fecha_final: Date | null
    activo: boolean | null
  }

  export type PeriodosCountAggregateOutputType = {
    id: number
    periodo: number
    fecha_inicio: number
    fecha_final: number
    activo: number
    _all: number
  }


  export type PeriodosAvgAggregateInputType = {
    id?: true
  }

  export type PeriodosSumAggregateInputType = {
    id?: true
  }

  export type PeriodosMinAggregateInputType = {
    id?: true
    periodo?: true
    fecha_inicio?: true
    fecha_final?: true
    activo?: true
  }

  export type PeriodosMaxAggregateInputType = {
    id?: true
    periodo?: true
    fecha_inicio?: true
    fecha_final?: true
    activo?: true
  }

  export type PeriodosCountAggregateInputType = {
    id?: true
    periodo?: true
    fecha_inicio?: true
    fecha_final?: true
    activo?: true
    _all?: true
  }

  export type PeriodosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which periodos to aggregate.
     */
    where?: periodosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of periodos to fetch.
     */
    orderBy?: periodosOrderByWithRelationInput | periodosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: periodosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` periodos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` periodos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned periodos
    **/
    _count?: true | PeriodosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PeriodosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PeriodosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PeriodosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PeriodosMaxAggregateInputType
  }

  export type GetPeriodosAggregateType<T extends PeriodosAggregateArgs> = {
        [P in keyof T & keyof AggregatePeriodos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePeriodos[P]>
      : GetScalarType<T[P], AggregatePeriodos[P]>
  }




  export type periodosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: periodosWhereInput
    orderBy?: periodosOrderByWithAggregationInput | periodosOrderByWithAggregationInput[]
    by: PeriodosScalarFieldEnum[] | PeriodosScalarFieldEnum
    having?: periodosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PeriodosCountAggregateInputType | true
    _avg?: PeriodosAvgAggregateInputType
    _sum?: PeriodosSumAggregateInputType
    _min?: PeriodosMinAggregateInputType
    _max?: PeriodosMaxAggregateInputType
  }

  export type PeriodosGroupByOutputType = {
    id: number
    periodo: string | null
    fecha_inicio: Date | null
    fecha_final: Date | null
    activo: boolean | null
    _count: PeriodosCountAggregateOutputType | null
    _avg: PeriodosAvgAggregateOutputType | null
    _sum: PeriodosSumAggregateOutputType | null
    _min: PeriodosMinAggregateOutputType | null
    _max: PeriodosMaxAggregateOutputType | null
  }

  type GetPeriodosGroupByPayload<T extends periodosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PeriodosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PeriodosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PeriodosGroupByOutputType[P]>
            : GetScalarType<T[P], PeriodosGroupByOutputType[P]>
        }
      >
    >


  export type periodosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    periodo?: boolean
    fecha_inicio?: boolean
    fecha_final?: boolean
    activo?: boolean
  }, ExtArgs["result"]["periodos"]>



  export type periodosSelectScalar = {
    id?: boolean
    periodo?: boolean
    fecha_inicio?: boolean
    fecha_final?: boolean
    activo?: boolean
  }

  export type periodosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "periodo" | "fecha_inicio" | "fecha_final" | "activo", ExtArgs["result"]["periodos"]>

  export type $periodosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "periodos"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      periodo: string | null
      fecha_inicio: Date | null
      fecha_final: Date | null
      activo: boolean | null
    }, ExtArgs["result"]["periodos"]>
    composites: {}
  }

  type periodosGetPayload<S extends boolean | null | undefined | periodosDefaultArgs> = $Result.GetResult<Prisma.$periodosPayload, S>

  type periodosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<periodosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PeriodosCountAggregateInputType | true
    }

  export interface periodosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['periodos'], meta: { name: 'periodos' } }
    /**
     * Find zero or one Periodos that matches the filter.
     * @param {periodosFindUniqueArgs} args - Arguments to find a Periodos
     * @example
     * // Get one Periodos
     * const periodos = await prisma.periodos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends periodosFindUniqueArgs>(args: SelectSubset<T, periodosFindUniqueArgs<ExtArgs>>): Prisma__periodosClient<$Result.GetResult<Prisma.$periodosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Periodos that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {periodosFindUniqueOrThrowArgs} args - Arguments to find a Periodos
     * @example
     * // Get one Periodos
     * const periodos = await prisma.periodos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends periodosFindUniqueOrThrowArgs>(args: SelectSubset<T, periodosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__periodosClient<$Result.GetResult<Prisma.$periodosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Periodos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {periodosFindFirstArgs} args - Arguments to find a Periodos
     * @example
     * // Get one Periodos
     * const periodos = await prisma.periodos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends periodosFindFirstArgs>(args?: SelectSubset<T, periodosFindFirstArgs<ExtArgs>>): Prisma__periodosClient<$Result.GetResult<Prisma.$periodosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Periodos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {periodosFindFirstOrThrowArgs} args - Arguments to find a Periodos
     * @example
     * // Get one Periodos
     * const periodos = await prisma.periodos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends periodosFindFirstOrThrowArgs>(args?: SelectSubset<T, periodosFindFirstOrThrowArgs<ExtArgs>>): Prisma__periodosClient<$Result.GetResult<Prisma.$periodosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Periodos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {periodosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Periodos
     * const periodos = await prisma.periodos.findMany()
     * 
     * // Get first 10 Periodos
     * const periodos = await prisma.periodos.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const periodosWithIdOnly = await prisma.periodos.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends periodosFindManyArgs>(args?: SelectSubset<T, periodosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$periodosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Periodos.
     * @param {periodosCreateArgs} args - Arguments to create a Periodos.
     * @example
     * // Create one Periodos
     * const Periodos = await prisma.periodos.create({
     *   data: {
     *     // ... data to create a Periodos
     *   }
     * })
     * 
     */
    create<T extends periodosCreateArgs>(args: SelectSubset<T, periodosCreateArgs<ExtArgs>>): Prisma__periodosClient<$Result.GetResult<Prisma.$periodosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Periodos.
     * @param {periodosCreateManyArgs} args - Arguments to create many Periodos.
     * @example
     * // Create many Periodos
     * const periodos = await prisma.periodos.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends periodosCreateManyArgs>(args?: SelectSubset<T, periodosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Periodos.
     * @param {periodosDeleteArgs} args - Arguments to delete one Periodos.
     * @example
     * // Delete one Periodos
     * const Periodos = await prisma.periodos.delete({
     *   where: {
     *     // ... filter to delete one Periodos
     *   }
     * })
     * 
     */
    delete<T extends periodosDeleteArgs>(args: SelectSubset<T, periodosDeleteArgs<ExtArgs>>): Prisma__periodosClient<$Result.GetResult<Prisma.$periodosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Periodos.
     * @param {periodosUpdateArgs} args - Arguments to update one Periodos.
     * @example
     * // Update one Periodos
     * const periodos = await prisma.periodos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends periodosUpdateArgs>(args: SelectSubset<T, periodosUpdateArgs<ExtArgs>>): Prisma__periodosClient<$Result.GetResult<Prisma.$periodosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Periodos.
     * @param {periodosDeleteManyArgs} args - Arguments to filter Periodos to delete.
     * @example
     * // Delete a few Periodos
     * const { count } = await prisma.periodos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends periodosDeleteManyArgs>(args?: SelectSubset<T, periodosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Periodos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {periodosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Periodos
     * const periodos = await prisma.periodos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends periodosUpdateManyArgs>(args: SelectSubset<T, periodosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Periodos.
     * @param {periodosUpsertArgs} args - Arguments to update or create a Periodos.
     * @example
     * // Update or create a Periodos
     * const periodos = await prisma.periodos.upsert({
     *   create: {
     *     // ... data to create a Periodos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Periodos we want to update
     *   }
     * })
     */
    upsert<T extends periodosUpsertArgs>(args: SelectSubset<T, periodosUpsertArgs<ExtArgs>>): Prisma__periodosClient<$Result.GetResult<Prisma.$periodosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Periodos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {periodosCountArgs} args - Arguments to filter Periodos to count.
     * @example
     * // Count the number of Periodos
     * const count = await prisma.periodos.count({
     *   where: {
     *     // ... the filter for the Periodos we want to count
     *   }
     * })
    **/
    count<T extends periodosCountArgs>(
      args?: Subset<T, periodosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PeriodosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Periodos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PeriodosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PeriodosAggregateArgs>(args: Subset<T, PeriodosAggregateArgs>): Prisma.PrismaPromise<GetPeriodosAggregateType<T>>

    /**
     * Group by Periodos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {periodosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends periodosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: periodosGroupByArgs['orderBy'] }
        : { orderBy?: periodosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, periodosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPeriodosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the periodos model
   */
  readonly fields: periodosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for periodos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__periodosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the periodos model
   */
  interface periodosFieldRefs {
    readonly id: FieldRef<"periodos", 'Int'>
    readonly periodo: FieldRef<"periodos", 'String'>
    readonly fecha_inicio: FieldRef<"periodos", 'DateTime'>
    readonly fecha_final: FieldRef<"periodos", 'DateTime'>
    readonly activo: FieldRef<"periodos", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * periodos findUnique
   */
  export type periodosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the periodos
     */
    select?: periodosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the periodos
     */
    omit?: periodosOmit<ExtArgs> | null
    /**
     * Filter, which periodos to fetch.
     */
    where: periodosWhereUniqueInput
  }

  /**
   * periodos findUniqueOrThrow
   */
  export type periodosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the periodos
     */
    select?: periodosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the periodos
     */
    omit?: periodosOmit<ExtArgs> | null
    /**
     * Filter, which periodos to fetch.
     */
    where: periodosWhereUniqueInput
  }

  /**
   * periodos findFirst
   */
  export type periodosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the periodos
     */
    select?: periodosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the periodos
     */
    omit?: periodosOmit<ExtArgs> | null
    /**
     * Filter, which periodos to fetch.
     */
    where?: periodosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of periodos to fetch.
     */
    orderBy?: periodosOrderByWithRelationInput | periodosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for periodos.
     */
    cursor?: periodosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` periodos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` periodos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of periodos.
     */
    distinct?: PeriodosScalarFieldEnum | PeriodosScalarFieldEnum[]
  }

  /**
   * periodos findFirstOrThrow
   */
  export type periodosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the periodos
     */
    select?: periodosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the periodos
     */
    omit?: periodosOmit<ExtArgs> | null
    /**
     * Filter, which periodos to fetch.
     */
    where?: periodosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of periodos to fetch.
     */
    orderBy?: periodosOrderByWithRelationInput | periodosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for periodos.
     */
    cursor?: periodosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` periodos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` periodos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of periodos.
     */
    distinct?: PeriodosScalarFieldEnum | PeriodosScalarFieldEnum[]
  }

  /**
   * periodos findMany
   */
  export type periodosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the periodos
     */
    select?: periodosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the periodos
     */
    omit?: periodosOmit<ExtArgs> | null
    /**
     * Filter, which periodos to fetch.
     */
    where?: periodosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of periodos to fetch.
     */
    orderBy?: periodosOrderByWithRelationInput | periodosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing periodos.
     */
    cursor?: periodosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` periodos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` periodos.
     */
    skip?: number
    distinct?: PeriodosScalarFieldEnum | PeriodosScalarFieldEnum[]
  }

  /**
   * periodos create
   */
  export type periodosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the periodos
     */
    select?: periodosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the periodos
     */
    omit?: periodosOmit<ExtArgs> | null
    /**
     * The data needed to create a periodos.
     */
    data?: XOR<periodosCreateInput, periodosUncheckedCreateInput>
  }

  /**
   * periodos createMany
   */
  export type periodosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many periodos.
     */
    data: periodosCreateManyInput | periodosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * periodos update
   */
  export type periodosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the periodos
     */
    select?: periodosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the periodos
     */
    omit?: periodosOmit<ExtArgs> | null
    /**
     * The data needed to update a periodos.
     */
    data: XOR<periodosUpdateInput, periodosUncheckedUpdateInput>
    /**
     * Choose, which periodos to update.
     */
    where: periodosWhereUniqueInput
  }

  /**
   * periodos updateMany
   */
  export type periodosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update periodos.
     */
    data: XOR<periodosUpdateManyMutationInput, periodosUncheckedUpdateManyInput>
    /**
     * Filter which periodos to update
     */
    where?: periodosWhereInput
    /**
     * Limit how many periodos to update.
     */
    limit?: number
  }

  /**
   * periodos upsert
   */
  export type periodosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the periodos
     */
    select?: periodosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the periodos
     */
    omit?: periodosOmit<ExtArgs> | null
    /**
     * The filter to search for the periodos to update in case it exists.
     */
    where: periodosWhereUniqueInput
    /**
     * In case the periodos found by the `where` argument doesn't exist, create a new periodos with this data.
     */
    create: XOR<periodosCreateInput, periodosUncheckedCreateInput>
    /**
     * In case the periodos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<periodosUpdateInput, periodosUncheckedUpdateInput>
  }

  /**
   * periodos delete
   */
  export type periodosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the periodos
     */
    select?: periodosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the periodos
     */
    omit?: periodosOmit<ExtArgs> | null
    /**
     * Filter which periodos to delete.
     */
    where: periodosWhereUniqueInput
  }

  /**
   * periodos deleteMany
   */
  export type periodosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which periodos to delete
     */
    where?: periodosWhereInput
    /**
     * Limit how many periodos to delete.
     */
    limit?: number
  }

  /**
   * periodos without action
   */
  export type periodosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the periodos
     */
    select?: periodosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the periodos
     */
    omit?: periodosOmit<ExtArgs> | null
  }


  /**
   * Model procesos
   */

  export type AggregateProcesos = {
    _count: ProcesosCountAggregateOutputType | null
    _avg: ProcesosAvgAggregateOutputType | null
    _sum: ProcesosSumAggregateOutputType | null
    _min: ProcesosMinAggregateOutputType | null
    _max: ProcesosMaxAggregateOutputType | null
  }

  export type ProcesosAvgAggregateOutputType = {
    id: number | null
    departamentos_id: number | null
    periodos_id: number | null
  }

  export type ProcesosSumAggregateOutputType = {
    id: number | null
    departamentos_id: number | null
    periodos_id: number | null
  }

  export type ProcesosMinAggregateOutputType = {
    id: number | null
    estatus: $Enums.procesos_estatus | null
    resultado: $Enums.procesos_resultado | null
    fecha_inicio: Date | null
    fecha_fin: Date | null
    departamentos_id: number | null
    periodos_id: number | null
  }

  export type ProcesosMaxAggregateOutputType = {
    id: number | null
    estatus: $Enums.procesos_estatus | null
    resultado: $Enums.procesos_resultado | null
    fecha_inicio: Date | null
    fecha_fin: Date | null
    departamentos_id: number | null
    periodos_id: number | null
  }

  export type ProcesosCountAggregateOutputType = {
    id: number
    estatus: number
    resultado: number
    fecha_inicio: number
    fecha_fin: number
    departamentos_id: number
    periodos_id: number
    _all: number
  }


  export type ProcesosAvgAggregateInputType = {
    id?: true
    departamentos_id?: true
    periodos_id?: true
  }

  export type ProcesosSumAggregateInputType = {
    id?: true
    departamentos_id?: true
    periodos_id?: true
  }

  export type ProcesosMinAggregateInputType = {
    id?: true
    estatus?: true
    resultado?: true
    fecha_inicio?: true
    fecha_fin?: true
    departamentos_id?: true
    periodos_id?: true
  }

  export type ProcesosMaxAggregateInputType = {
    id?: true
    estatus?: true
    resultado?: true
    fecha_inicio?: true
    fecha_fin?: true
    departamentos_id?: true
    periodos_id?: true
  }

  export type ProcesosCountAggregateInputType = {
    id?: true
    estatus?: true
    resultado?: true
    fecha_inicio?: true
    fecha_fin?: true
    departamentos_id?: true
    periodos_id?: true
    _all?: true
  }

  export type ProcesosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which procesos to aggregate.
     */
    where?: procesosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of procesos to fetch.
     */
    orderBy?: procesosOrderByWithRelationInput | procesosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: procesosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` procesos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` procesos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned procesos
    **/
    _count?: true | ProcesosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProcesosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProcesosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProcesosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProcesosMaxAggregateInputType
  }

  export type GetProcesosAggregateType<T extends ProcesosAggregateArgs> = {
        [P in keyof T & keyof AggregateProcesos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProcesos[P]>
      : GetScalarType<T[P], AggregateProcesos[P]>
  }




  export type procesosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: procesosWhereInput
    orderBy?: procesosOrderByWithAggregationInput | procesosOrderByWithAggregationInput[]
    by: ProcesosScalarFieldEnum[] | ProcesosScalarFieldEnum
    having?: procesosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProcesosCountAggregateInputType | true
    _avg?: ProcesosAvgAggregateInputType
    _sum?: ProcesosSumAggregateInputType
    _min?: ProcesosMinAggregateInputType
    _max?: ProcesosMaxAggregateInputType
  }

  export type ProcesosGroupByOutputType = {
    id: number
    estatus: $Enums.procesos_estatus
    resultado: $Enums.procesos_resultado | null
    fecha_inicio: Date | null
    fecha_fin: Date | null
    departamentos_id: number | null
    periodos_id: number | null
    _count: ProcesosCountAggregateOutputType | null
    _avg: ProcesosAvgAggregateOutputType | null
    _sum: ProcesosSumAggregateOutputType | null
    _min: ProcesosMinAggregateOutputType | null
    _max: ProcesosMaxAggregateOutputType | null
  }

  type GetProcesosGroupByPayload<T extends procesosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProcesosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProcesosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProcesosGroupByOutputType[P]>
            : GetScalarType<T[P], ProcesosGroupByOutputType[P]>
        }
      >
    >


  export type procesosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    estatus?: boolean
    resultado?: boolean
    fecha_inicio?: boolean
    fecha_fin?: boolean
    departamentos_id?: boolean
    periodos_id?: boolean
  }, ExtArgs["result"]["procesos"]>



  export type procesosSelectScalar = {
    id?: boolean
    estatus?: boolean
    resultado?: boolean
    fecha_inicio?: boolean
    fecha_fin?: boolean
    departamentos_id?: boolean
    periodos_id?: boolean
  }

  export type procesosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "estatus" | "resultado" | "fecha_inicio" | "fecha_fin" | "departamentos_id" | "periodos_id", ExtArgs["result"]["procesos"]>

  export type $procesosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "procesos"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      estatus: $Enums.procesos_estatus
      resultado: $Enums.procesos_resultado | null
      fecha_inicio: Date | null
      fecha_fin: Date | null
      departamentos_id: number | null
      periodos_id: number | null
    }, ExtArgs["result"]["procesos"]>
    composites: {}
  }

  type procesosGetPayload<S extends boolean | null | undefined | procesosDefaultArgs> = $Result.GetResult<Prisma.$procesosPayload, S>

  type procesosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<procesosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProcesosCountAggregateInputType | true
    }

  export interface procesosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['procesos'], meta: { name: 'procesos' } }
    /**
     * Find zero or one Procesos that matches the filter.
     * @param {procesosFindUniqueArgs} args - Arguments to find a Procesos
     * @example
     * // Get one Procesos
     * const procesos = await prisma.procesos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends procesosFindUniqueArgs>(args: SelectSubset<T, procesosFindUniqueArgs<ExtArgs>>): Prisma__procesosClient<$Result.GetResult<Prisma.$procesosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Procesos that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {procesosFindUniqueOrThrowArgs} args - Arguments to find a Procesos
     * @example
     * // Get one Procesos
     * const procesos = await prisma.procesos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends procesosFindUniqueOrThrowArgs>(args: SelectSubset<T, procesosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__procesosClient<$Result.GetResult<Prisma.$procesosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Procesos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {procesosFindFirstArgs} args - Arguments to find a Procesos
     * @example
     * // Get one Procesos
     * const procesos = await prisma.procesos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends procesosFindFirstArgs>(args?: SelectSubset<T, procesosFindFirstArgs<ExtArgs>>): Prisma__procesosClient<$Result.GetResult<Prisma.$procesosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Procesos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {procesosFindFirstOrThrowArgs} args - Arguments to find a Procesos
     * @example
     * // Get one Procesos
     * const procesos = await prisma.procesos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends procesosFindFirstOrThrowArgs>(args?: SelectSubset<T, procesosFindFirstOrThrowArgs<ExtArgs>>): Prisma__procesosClient<$Result.GetResult<Prisma.$procesosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Procesos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {procesosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Procesos
     * const procesos = await prisma.procesos.findMany()
     * 
     * // Get first 10 Procesos
     * const procesos = await prisma.procesos.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const procesosWithIdOnly = await prisma.procesos.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends procesosFindManyArgs>(args?: SelectSubset<T, procesosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$procesosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Procesos.
     * @param {procesosCreateArgs} args - Arguments to create a Procesos.
     * @example
     * // Create one Procesos
     * const Procesos = await prisma.procesos.create({
     *   data: {
     *     // ... data to create a Procesos
     *   }
     * })
     * 
     */
    create<T extends procesosCreateArgs>(args: SelectSubset<T, procesosCreateArgs<ExtArgs>>): Prisma__procesosClient<$Result.GetResult<Prisma.$procesosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Procesos.
     * @param {procesosCreateManyArgs} args - Arguments to create many Procesos.
     * @example
     * // Create many Procesos
     * const procesos = await prisma.procesos.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends procesosCreateManyArgs>(args?: SelectSubset<T, procesosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Procesos.
     * @param {procesosDeleteArgs} args - Arguments to delete one Procesos.
     * @example
     * // Delete one Procesos
     * const Procesos = await prisma.procesos.delete({
     *   where: {
     *     // ... filter to delete one Procesos
     *   }
     * })
     * 
     */
    delete<T extends procesosDeleteArgs>(args: SelectSubset<T, procesosDeleteArgs<ExtArgs>>): Prisma__procesosClient<$Result.GetResult<Prisma.$procesosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Procesos.
     * @param {procesosUpdateArgs} args - Arguments to update one Procesos.
     * @example
     * // Update one Procesos
     * const procesos = await prisma.procesos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends procesosUpdateArgs>(args: SelectSubset<T, procesosUpdateArgs<ExtArgs>>): Prisma__procesosClient<$Result.GetResult<Prisma.$procesosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Procesos.
     * @param {procesosDeleteManyArgs} args - Arguments to filter Procesos to delete.
     * @example
     * // Delete a few Procesos
     * const { count } = await prisma.procesos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends procesosDeleteManyArgs>(args?: SelectSubset<T, procesosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Procesos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {procesosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Procesos
     * const procesos = await prisma.procesos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends procesosUpdateManyArgs>(args: SelectSubset<T, procesosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Procesos.
     * @param {procesosUpsertArgs} args - Arguments to update or create a Procesos.
     * @example
     * // Update or create a Procesos
     * const procesos = await prisma.procesos.upsert({
     *   create: {
     *     // ... data to create a Procesos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Procesos we want to update
     *   }
     * })
     */
    upsert<T extends procesosUpsertArgs>(args: SelectSubset<T, procesosUpsertArgs<ExtArgs>>): Prisma__procesosClient<$Result.GetResult<Prisma.$procesosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Procesos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {procesosCountArgs} args - Arguments to filter Procesos to count.
     * @example
     * // Count the number of Procesos
     * const count = await prisma.procesos.count({
     *   where: {
     *     // ... the filter for the Procesos we want to count
     *   }
     * })
    **/
    count<T extends procesosCountArgs>(
      args?: Subset<T, procesosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProcesosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Procesos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcesosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProcesosAggregateArgs>(args: Subset<T, ProcesosAggregateArgs>): Prisma.PrismaPromise<GetProcesosAggregateType<T>>

    /**
     * Group by Procesos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {procesosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends procesosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: procesosGroupByArgs['orderBy'] }
        : { orderBy?: procesosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, procesosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProcesosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the procesos model
   */
  readonly fields: procesosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for procesos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__procesosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the procesos model
   */
  interface procesosFieldRefs {
    readonly id: FieldRef<"procesos", 'Int'>
    readonly estatus: FieldRef<"procesos", 'procesos_estatus'>
    readonly resultado: FieldRef<"procesos", 'procesos_resultado'>
    readonly fecha_inicio: FieldRef<"procesos", 'DateTime'>
    readonly fecha_fin: FieldRef<"procesos", 'DateTime'>
    readonly departamentos_id: FieldRef<"procesos", 'Int'>
    readonly periodos_id: FieldRef<"procesos", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * procesos findUnique
   */
  export type procesosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the procesos
     */
    select?: procesosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the procesos
     */
    omit?: procesosOmit<ExtArgs> | null
    /**
     * Filter, which procesos to fetch.
     */
    where: procesosWhereUniqueInput
  }

  /**
   * procesos findUniqueOrThrow
   */
  export type procesosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the procesos
     */
    select?: procesosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the procesos
     */
    omit?: procesosOmit<ExtArgs> | null
    /**
     * Filter, which procesos to fetch.
     */
    where: procesosWhereUniqueInput
  }

  /**
   * procesos findFirst
   */
  export type procesosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the procesos
     */
    select?: procesosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the procesos
     */
    omit?: procesosOmit<ExtArgs> | null
    /**
     * Filter, which procesos to fetch.
     */
    where?: procesosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of procesos to fetch.
     */
    orderBy?: procesosOrderByWithRelationInput | procesosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for procesos.
     */
    cursor?: procesosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` procesos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` procesos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of procesos.
     */
    distinct?: ProcesosScalarFieldEnum | ProcesosScalarFieldEnum[]
  }

  /**
   * procesos findFirstOrThrow
   */
  export type procesosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the procesos
     */
    select?: procesosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the procesos
     */
    omit?: procesosOmit<ExtArgs> | null
    /**
     * Filter, which procesos to fetch.
     */
    where?: procesosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of procesos to fetch.
     */
    orderBy?: procesosOrderByWithRelationInput | procesosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for procesos.
     */
    cursor?: procesosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` procesos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` procesos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of procesos.
     */
    distinct?: ProcesosScalarFieldEnum | ProcesosScalarFieldEnum[]
  }

  /**
   * procesos findMany
   */
  export type procesosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the procesos
     */
    select?: procesosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the procesos
     */
    omit?: procesosOmit<ExtArgs> | null
    /**
     * Filter, which procesos to fetch.
     */
    where?: procesosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of procesos to fetch.
     */
    orderBy?: procesosOrderByWithRelationInput | procesosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing procesos.
     */
    cursor?: procesosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` procesos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` procesos.
     */
    skip?: number
    distinct?: ProcesosScalarFieldEnum | ProcesosScalarFieldEnum[]
  }

  /**
   * procesos create
   */
  export type procesosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the procesos
     */
    select?: procesosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the procesos
     */
    omit?: procesosOmit<ExtArgs> | null
    /**
     * The data needed to create a procesos.
     */
    data: XOR<procesosCreateInput, procesosUncheckedCreateInput>
  }

  /**
   * procesos createMany
   */
  export type procesosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many procesos.
     */
    data: procesosCreateManyInput | procesosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * procesos update
   */
  export type procesosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the procesos
     */
    select?: procesosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the procesos
     */
    omit?: procesosOmit<ExtArgs> | null
    /**
     * The data needed to update a procesos.
     */
    data: XOR<procesosUpdateInput, procesosUncheckedUpdateInput>
    /**
     * Choose, which procesos to update.
     */
    where: procesosWhereUniqueInput
  }

  /**
   * procesos updateMany
   */
  export type procesosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update procesos.
     */
    data: XOR<procesosUpdateManyMutationInput, procesosUncheckedUpdateManyInput>
    /**
     * Filter which procesos to update
     */
    where?: procesosWhereInput
    /**
     * Limit how many procesos to update.
     */
    limit?: number
  }

  /**
   * procesos upsert
   */
  export type procesosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the procesos
     */
    select?: procesosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the procesos
     */
    omit?: procesosOmit<ExtArgs> | null
    /**
     * The filter to search for the procesos to update in case it exists.
     */
    where: procesosWhereUniqueInput
    /**
     * In case the procesos found by the `where` argument doesn't exist, create a new procesos with this data.
     */
    create: XOR<procesosCreateInput, procesosUncheckedCreateInput>
    /**
     * In case the procesos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<procesosUpdateInput, procesosUncheckedUpdateInput>
  }

  /**
   * procesos delete
   */
  export type procesosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the procesos
     */
    select?: procesosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the procesos
     */
    omit?: procesosOmit<ExtArgs> | null
    /**
     * Filter which procesos to delete.
     */
    where: procesosWhereUniqueInput
  }

  /**
   * procesos deleteMany
   */
  export type procesosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which procesos to delete
     */
    where?: procesosWhereInput
    /**
     * Limit how many procesos to delete.
     */
    limit?: number
  }

  /**
   * procesos without action
   */
  export type procesosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the procesos
     */
    select?: procesosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the procesos
     */
    omit?: procesosOmit<ExtArgs> | null
  }


  /**
   * Model roles
   */

  export type AggregateRoles = {
    _count: RolesCountAggregateOutputType | null
    _avg: RolesAvgAggregateOutputType | null
    _sum: RolesSumAggregateOutputType | null
    _min: RolesMinAggregateOutputType | null
    _max: RolesMaxAggregateOutputType | null
  }

  export type RolesAvgAggregateOutputType = {
    id: number | null
  }

  export type RolesSumAggregateOutputType = {
    id: number | null
  }

  export type RolesMinAggregateOutputType = {
    id: number | null
    tipo: $Enums.roles_tipo | null
    descripcion: string | null
    activo: boolean | null
    fecha_creacion: Date | null
  }

  export type RolesMaxAggregateOutputType = {
    id: number | null
    tipo: $Enums.roles_tipo | null
    descripcion: string | null
    activo: boolean | null
    fecha_creacion: Date | null
  }

  export type RolesCountAggregateOutputType = {
    id: number
    tipo: number
    descripcion: number
    activo: number
    fecha_creacion: number
    _all: number
  }


  export type RolesAvgAggregateInputType = {
    id?: true
  }

  export type RolesSumAggregateInputType = {
    id?: true
  }

  export type RolesMinAggregateInputType = {
    id?: true
    tipo?: true
    descripcion?: true
    activo?: true
    fecha_creacion?: true
  }

  export type RolesMaxAggregateInputType = {
    id?: true
    tipo?: true
    descripcion?: true
    activo?: true
    fecha_creacion?: true
  }

  export type RolesCountAggregateInputType = {
    id?: true
    tipo?: true
    descripcion?: true
    activo?: true
    fecha_creacion?: true
    _all?: true
  }

  export type RolesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which roles to aggregate.
     */
    where?: rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: rolesOrderByWithRelationInput | rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned roles
    **/
    _count?: true | RolesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RolesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RolesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolesMaxAggregateInputType
  }

  export type GetRolesAggregateType<T extends RolesAggregateArgs> = {
        [P in keyof T & keyof AggregateRoles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoles[P]>
      : GetScalarType<T[P], AggregateRoles[P]>
  }




  export type rolesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rolesWhereInput
    orderBy?: rolesOrderByWithAggregationInput | rolesOrderByWithAggregationInput[]
    by: RolesScalarFieldEnum[] | RolesScalarFieldEnum
    having?: rolesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolesCountAggregateInputType | true
    _avg?: RolesAvgAggregateInputType
    _sum?: RolesSumAggregateInputType
    _min?: RolesMinAggregateInputType
    _max?: RolesMaxAggregateInputType
  }

  export type RolesGroupByOutputType = {
    id: number
    tipo: $Enums.roles_tipo
    descripcion: string | null
    activo: boolean | null
    fecha_creacion: Date | null
    _count: RolesCountAggregateOutputType | null
    _avg: RolesAvgAggregateOutputType | null
    _sum: RolesSumAggregateOutputType | null
    _min: RolesMinAggregateOutputType | null
    _max: RolesMaxAggregateOutputType | null
  }

  type GetRolesGroupByPayload<T extends rolesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolesGroupByOutputType[P]>
            : GetScalarType<T[P], RolesGroupByOutputType[P]>
        }
      >
    >


  export type rolesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tipo?: boolean
    descripcion?: boolean
    activo?: boolean
    fecha_creacion?: boolean
    usuarios_has_roles?: boolean | roles$usuarios_has_rolesArgs<ExtArgs>
    _count?: boolean | RolesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roles"]>



  export type rolesSelectScalar = {
    id?: boolean
    tipo?: boolean
    descripcion?: boolean
    activo?: boolean
    fecha_creacion?: boolean
  }

  export type rolesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tipo" | "descripcion" | "activo" | "fecha_creacion", ExtArgs["result"]["roles"]>
  export type rolesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuarios_has_roles?: boolean | roles$usuarios_has_rolesArgs<ExtArgs>
    _count?: boolean | RolesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $rolesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "roles"
    objects: {
      usuarios_has_roles: Prisma.$usuarios_has_rolesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tipo: $Enums.roles_tipo
      descripcion: string | null
      activo: boolean | null
      fecha_creacion: Date | null
    }, ExtArgs["result"]["roles"]>
    composites: {}
  }

  type rolesGetPayload<S extends boolean | null | undefined | rolesDefaultArgs> = $Result.GetResult<Prisma.$rolesPayload, S>

  type rolesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<rolesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RolesCountAggregateInputType | true
    }

  export interface rolesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['roles'], meta: { name: 'roles' } }
    /**
     * Find zero or one Roles that matches the filter.
     * @param {rolesFindUniqueArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends rolesFindUniqueArgs>(args: SelectSubset<T, rolesFindUniqueArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Roles that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {rolesFindUniqueOrThrowArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends rolesFindUniqueOrThrowArgs>(args: SelectSubset<T, rolesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesFindFirstArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends rolesFindFirstArgs>(args?: SelectSubset<T, rolesFindFirstArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Roles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesFindFirstOrThrowArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends rolesFindFirstOrThrowArgs>(args?: SelectSubset<T, rolesFindFirstOrThrowArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.roles.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.roles.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rolesWithIdOnly = await prisma.roles.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends rolesFindManyArgs>(args?: SelectSubset<T, rolesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Roles.
     * @param {rolesCreateArgs} args - Arguments to create a Roles.
     * @example
     * // Create one Roles
     * const Roles = await prisma.roles.create({
     *   data: {
     *     // ... data to create a Roles
     *   }
     * })
     * 
     */
    create<T extends rolesCreateArgs>(args: SelectSubset<T, rolesCreateArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Roles.
     * @param {rolesCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const roles = await prisma.roles.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends rolesCreateManyArgs>(args?: SelectSubset<T, rolesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Roles.
     * @param {rolesDeleteArgs} args - Arguments to delete one Roles.
     * @example
     * // Delete one Roles
     * const Roles = await prisma.roles.delete({
     *   where: {
     *     // ... filter to delete one Roles
     *   }
     * })
     * 
     */
    delete<T extends rolesDeleteArgs>(args: SelectSubset<T, rolesDeleteArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Roles.
     * @param {rolesUpdateArgs} args - Arguments to update one Roles.
     * @example
     * // Update one Roles
     * const roles = await prisma.roles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends rolesUpdateArgs>(args: SelectSubset<T, rolesUpdateArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Roles.
     * @param {rolesDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.roles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends rolesDeleteManyArgs>(args?: SelectSubset<T, rolesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const roles = await prisma.roles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends rolesUpdateManyArgs>(args: SelectSubset<T, rolesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Roles.
     * @param {rolesUpsertArgs} args - Arguments to update or create a Roles.
     * @example
     * // Update or create a Roles
     * const roles = await prisma.roles.upsert({
     *   create: {
     *     // ... data to create a Roles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Roles we want to update
     *   }
     * })
     */
    upsert<T extends rolesUpsertArgs>(args: SelectSubset<T, rolesUpsertArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.roles.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends rolesCountArgs>(
      args?: Subset<T, rolesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolesAggregateArgs>(args: Subset<T, RolesAggregateArgs>): Prisma.PrismaPromise<GetRolesAggregateType<T>>

    /**
     * Group by Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends rolesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: rolesGroupByArgs['orderBy'] }
        : { orderBy?: rolesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, rolesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the roles model
   */
  readonly fields: rolesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for roles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__rolesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuarios_has_roles<T extends roles$usuarios_has_rolesArgs<ExtArgs> = {}>(args?: Subset<T, roles$usuarios_has_rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usuarios_has_rolesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the roles model
   */
  interface rolesFieldRefs {
    readonly id: FieldRef<"roles", 'Int'>
    readonly tipo: FieldRef<"roles", 'roles_tipo'>
    readonly descripcion: FieldRef<"roles", 'String'>
    readonly activo: FieldRef<"roles", 'Boolean'>
    readonly fecha_creacion: FieldRef<"roles", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * roles findUnique
   */
  export type rolesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where: rolesWhereUniqueInput
  }

  /**
   * roles findUniqueOrThrow
   */
  export type rolesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where: rolesWhereUniqueInput
  }

  /**
   * roles findFirst
   */
  export type rolesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where?: rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: rolesOrderByWithRelationInput | rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for roles.
     */
    cursor?: rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of roles.
     */
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }

  /**
   * roles findFirstOrThrow
   */
  export type rolesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where?: rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: rolesOrderByWithRelationInput | rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for roles.
     */
    cursor?: rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of roles.
     */
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }

  /**
   * roles findMany
   */
  export type rolesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where?: rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: rolesOrderByWithRelationInput | rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing roles.
     */
    cursor?: rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }

  /**
   * roles create
   */
  export type rolesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * The data needed to create a roles.
     */
    data: XOR<rolesCreateInput, rolesUncheckedCreateInput>
  }

  /**
   * roles createMany
   */
  export type rolesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many roles.
     */
    data: rolesCreateManyInput | rolesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * roles update
   */
  export type rolesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * The data needed to update a roles.
     */
    data: XOR<rolesUpdateInput, rolesUncheckedUpdateInput>
    /**
     * Choose, which roles to update.
     */
    where: rolesWhereUniqueInput
  }

  /**
   * roles updateMany
   */
  export type rolesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update roles.
     */
    data: XOR<rolesUpdateManyMutationInput, rolesUncheckedUpdateManyInput>
    /**
     * Filter which roles to update
     */
    where?: rolesWhereInput
    /**
     * Limit how many roles to update.
     */
    limit?: number
  }

  /**
   * roles upsert
   */
  export type rolesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * The filter to search for the roles to update in case it exists.
     */
    where: rolesWhereUniqueInput
    /**
     * In case the roles found by the `where` argument doesn't exist, create a new roles with this data.
     */
    create: XOR<rolesCreateInput, rolesUncheckedCreateInput>
    /**
     * In case the roles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<rolesUpdateInput, rolesUncheckedUpdateInput>
  }

  /**
   * roles delete
   */
  export type rolesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter which roles to delete.
     */
    where: rolesWhereUniqueInput
  }

  /**
   * roles deleteMany
   */
  export type rolesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which roles to delete
     */
    where?: rolesWhereInput
    /**
     * Limit how many roles to delete.
     */
    limit?: number
  }

  /**
   * roles.usuarios_has_roles
   */
  export type roles$usuarios_has_rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuarios_has_roles
     */
    select?: usuarios_has_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuarios_has_roles
     */
    omit?: usuarios_has_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarios_has_rolesInclude<ExtArgs> | null
    where?: usuarios_has_rolesWhereInput
    orderBy?: usuarios_has_rolesOrderByWithRelationInput | usuarios_has_rolesOrderByWithRelationInput[]
    cursor?: usuarios_has_rolesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Usuarios_has_rolesScalarFieldEnum | Usuarios_has_rolesScalarFieldEnum[]
  }

  /**
   * roles without action
   */
  export type rolesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
  }


  /**
   * Model tipos_documentos
   */

  export type AggregateTipos_documentos = {
    _count: Tipos_documentosCountAggregateOutputType | null
    _avg: Tipos_documentosAvgAggregateOutputType | null
    _sum: Tipos_documentosSumAggregateOutputType | null
    _min: Tipos_documentosMinAggregateOutputType | null
    _max: Tipos_documentosMaxAggregateOutputType | null
  }

  export type Tipos_documentosAvgAggregateOutputType = {
    id: number | null
  }

  export type Tipos_documentosSumAggregateOutputType = {
    id: number | null
  }

  export type Tipos_documentosMinAggregateOutputType = {
    id: number | null
    tipo: string | null
  }

  export type Tipos_documentosMaxAggregateOutputType = {
    id: number | null
    tipo: string | null
  }

  export type Tipos_documentosCountAggregateOutputType = {
    id: number
    tipo: number
    _all: number
  }


  export type Tipos_documentosAvgAggregateInputType = {
    id?: true
  }

  export type Tipos_documentosSumAggregateInputType = {
    id?: true
  }

  export type Tipos_documentosMinAggregateInputType = {
    id?: true
    tipo?: true
  }

  export type Tipos_documentosMaxAggregateInputType = {
    id?: true
    tipo?: true
  }

  export type Tipos_documentosCountAggregateInputType = {
    id?: true
    tipo?: true
    _all?: true
  }

  export type Tipos_documentosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tipos_documentos to aggregate.
     */
    where?: tipos_documentosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tipos_documentos to fetch.
     */
    orderBy?: tipos_documentosOrderByWithRelationInput | tipos_documentosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tipos_documentosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tipos_documentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tipos_documentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tipos_documentos
    **/
    _count?: true | Tipos_documentosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tipos_documentosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tipos_documentosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tipos_documentosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tipos_documentosMaxAggregateInputType
  }

  export type GetTipos_documentosAggregateType<T extends Tipos_documentosAggregateArgs> = {
        [P in keyof T & keyof AggregateTipos_documentos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTipos_documentos[P]>
      : GetScalarType<T[P], AggregateTipos_documentos[P]>
  }




  export type tipos_documentosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tipos_documentosWhereInput
    orderBy?: tipos_documentosOrderByWithAggregationInput | tipos_documentosOrderByWithAggregationInput[]
    by: Tipos_documentosScalarFieldEnum[] | Tipos_documentosScalarFieldEnum
    having?: tipos_documentosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tipos_documentosCountAggregateInputType | true
    _avg?: Tipos_documentosAvgAggregateInputType
    _sum?: Tipos_documentosSumAggregateInputType
    _min?: Tipos_documentosMinAggregateInputType
    _max?: Tipos_documentosMaxAggregateInputType
  }

  export type Tipos_documentosGroupByOutputType = {
    id: number
    tipo: string | null
    _count: Tipos_documentosCountAggregateOutputType | null
    _avg: Tipos_documentosAvgAggregateOutputType | null
    _sum: Tipos_documentosSumAggregateOutputType | null
    _min: Tipos_documentosMinAggregateOutputType | null
    _max: Tipos_documentosMaxAggregateOutputType | null
  }

  type GetTipos_documentosGroupByPayload<T extends tipos_documentosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tipos_documentosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tipos_documentosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tipos_documentosGroupByOutputType[P]>
            : GetScalarType<T[P], Tipos_documentosGroupByOutputType[P]>
        }
      >
    >


  export type tipos_documentosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tipo?: boolean
    documentos?: boolean | tipos_documentos$documentosArgs<ExtArgs>
    _count?: boolean | Tipos_documentosCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tipos_documentos"]>



  export type tipos_documentosSelectScalar = {
    id?: boolean
    tipo?: boolean
  }

  export type tipos_documentosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tipo", ExtArgs["result"]["tipos_documentos"]>
  export type tipos_documentosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    documentos?: boolean | tipos_documentos$documentosArgs<ExtArgs>
    _count?: boolean | Tipos_documentosCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $tipos_documentosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tipos_documentos"
    objects: {
      documentos: Prisma.$documentosPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tipo: string | null
    }, ExtArgs["result"]["tipos_documentos"]>
    composites: {}
  }

  type tipos_documentosGetPayload<S extends boolean | null | undefined | tipos_documentosDefaultArgs> = $Result.GetResult<Prisma.$tipos_documentosPayload, S>

  type tipos_documentosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tipos_documentosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Tipos_documentosCountAggregateInputType | true
    }

  export interface tipos_documentosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tipos_documentos'], meta: { name: 'tipos_documentos' } }
    /**
     * Find zero or one Tipos_documentos that matches the filter.
     * @param {tipos_documentosFindUniqueArgs} args - Arguments to find a Tipos_documentos
     * @example
     * // Get one Tipos_documentos
     * const tipos_documentos = await prisma.tipos_documentos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tipos_documentosFindUniqueArgs>(args: SelectSubset<T, tipos_documentosFindUniqueArgs<ExtArgs>>): Prisma__tipos_documentosClient<$Result.GetResult<Prisma.$tipos_documentosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tipos_documentos that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tipos_documentosFindUniqueOrThrowArgs} args - Arguments to find a Tipos_documentos
     * @example
     * // Get one Tipos_documentos
     * const tipos_documentos = await prisma.tipos_documentos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tipos_documentosFindUniqueOrThrowArgs>(args: SelectSubset<T, tipos_documentosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tipos_documentosClient<$Result.GetResult<Prisma.$tipos_documentosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tipos_documentos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipos_documentosFindFirstArgs} args - Arguments to find a Tipos_documentos
     * @example
     * // Get one Tipos_documentos
     * const tipos_documentos = await prisma.tipos_documentos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tipos_documentosFindFirstArgs>(args?: SelectSubset<T, tipos_documentosFindFirstArgs<ExtArgs>>): Prisma__tipos_documentosClient<$Result.GetResult<Prisma.$tipos_documentosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tipos_documentos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipos_documentosFindFirstOrThrowArgs} args - Arguments to find a Tipos_documentos
     * @example
     * // Get one Tipos_documentos
     * const tipos_documentos = await prisma.tipos_documentos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tipos_documentosFindFirstOrThrowArgs>(args?: SelectSubset<T, tipos_documentosFindFirstOrThrowArgs<ExtArgs>>): Prisma__tipos_documentosClient<$Result.GetResult<Prisma.$tipos_documentosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tipos_documentos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipos_documentosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tipos_documentos
     * const tipos_documentos = await prisma.tipos_documentos.findMany()
     * 
     * // Get first 10 Tipos_documentos
     * const tipos_documentos = await prisma.tipos_documentos.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tipos_documentosWithIdOnly = await prisma.tipos_documentos.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends tipos_documentosFindManyArgs>(args?: SelectSubset<T, tipos_documentosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tipos_documentosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tipos_documentos.
     * @param {tipos_documentosCreateArgs} args - Arguments to create a Tipos_documentos.
     * @example
     * // Create one Tipos_documentos
     * const Tipos_documentos = await prisma.tipos_documentos.create({
     *   data: {
     *     // ... data to create a Tipos_documentos
     *   }
     * })
     * 
     */
    create<T extends tipos_documentosCreateArgs>(args: SelectSubset<T, tipos_documentosCreateArgs<ExtArgs>>): Prisma__tipos_documentosClient<$Result.GetResult<Prisma.$tipos_documentosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tipos_documentos.
     * @param {tipos_documentosCreateManyArgs} args - Arguments to create many Tipos_documentos.
     * @example
     * // Create many Tipos_documentos
     * const tipos_documentos = await prisma.tipos_documentos.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tipos_documentosCreateManyArgs>(args?: SelectSubset<T, tipos_documentosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tipos_documentos.
     * @param {tipos_documentosDeleteArgs} args - Arguments to delete one Tipos_documentos.
     * @example
     * // Delete one Tipos_documentos
     * const Tipos_documentos = await prisma.tipos_documentos.delete({
     *   where: {
     *     // ... filter to delete one Tipos_documentos
     *   }
     * })
     * 
     */
    delete<T extends tipos_documentosDeleteArgs>(args: SelectSubset<T, tipos_documentosDeleteArgs<ExtArgs>>): Prisma__tipos_documentosClient<$Result.GetResult<Prisma.$tipos_documentosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tipos_documentos.
     * @param {tipos_documentosUpdateArgs} args - Arguments to update one Tipos_documentos.
     * @example
     * // Update one Tipos_documentos
     * const tipos_documentos = await prisma.tipos_documentos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tipos_documentosUpdateArgs>(args: SelectSubset<T, tipos_documentosUpdateArgs<ExtArgs>>): Prisma__tipos_documentosClient<$Result.GetResult<Prisma.$tipos_documentosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tipos_documentos.
     * @param {tipos_documentosDeleteManyArgs} args - Arguments to filter Tipos_documentos to delete.
     * @example
     * // Delete a few Tipos_documentos
     * const { count } = await prisma.tipos_documentos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tipos_documentosDeleteManyArgs>(args?: SelectSubset<T, tipos_documentosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tipos_documentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipos_documentosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tipos_documentos
     * const tipos_documentos = await prisma.tipos_documentos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tipos_documentosUpdateManyArgs>(args: SelectSubset<T, tipos_documentosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tipos_documentos.
     * @param {tipos_documentosUpsertArgs} args - Arguments to update or create a Tipos_documentos.
     * @example
     * // Update or create a Tipos_documentos
     * const tipos_documentos = await prisma.tipos_documentos.upsert({
     *   create: {
     *     // ... data to create a Tipos_documentos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tipos_documentos we want to update
     *   }
     * })
     */
    upsert<T extends tipos_documentosUpsertArgs>(args: SelectSubset<T, tipos_documentosUpsertArgs<ExtArgs>>): Prisma__tipos_documentosClient<$Result.GetResult<Prisma.$tipos_documentosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tipos_documentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipos_documentosCountArgs} args - Arguments to filter Tipos_documentos to count.
     * @example
     * // Count the number of Tipos_documentos
     * const count = await prisma.tipos_documentos.count({
     *   where: {
     *     // ... the filter for the Tipos_documentos we want to count
     *   }
     * })
    **/
    count<T extends tipos_documentosCountArgs>(
      args?: Subset<T, tipos_documentosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tipos_documentosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tipos_documentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tipos_documentosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tipos_documentosAggregateArgs>(args: Subset<T, Tipos_documentosAggregateArgs>): Prisma.PrismaPromise<GetTipos_documentosAggregateType<T>>

    /**
     * Group by Tipos_documentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipos_documentosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tipos_documentosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tipos_documentosGroupByArgs['orderBy'] }
        : { orderBy?: tipos_documentosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tipos_documentosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTipos_documentosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tipos_documentos model
   */
  readonly fields: tipos_documentosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tipos_documentos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tipos_documentosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    documentos<T extends tipos_documentos$documentosArgs<ExtArgs> = {}>(args?: Subset<T, tipos_documentos$documentosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$documentosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tipos_documentos model
   */
  interface tipos_documentosFieldRefs {
    readonly id: FieldRef<"tipos_documentos", 'Int'>
    readonly tipo: FieldRef<"tipos_documentos", 'String'>
  }
    

  // Custom InputTypes
  /**
   * tipos_documentos findUnique
   */
  export type tipos_documentosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipos_documentos
     */
    select?: tipos_documentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipos_documentos
     */
    omit?: tipos_documentosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipos_documentosInclude<ExtArgs> | null
    /**
     * Filter, which tipos_documentos to fetch.
     */
    where: tipos_documentosWhereUniqueInput
  }

  /**
   * tipos_documentos findUniqueOrThrow
   */
  export type tipos_documentosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipos_documentos
     */
    select?: tipos_documentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipos_documentos
     */
    omit?: tipos_documentosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipos_documentosInclude<ExtArgs> | null
    /**
     * Filter, which tipos_documentos to fetch.
     */
    where: tipos_documentosWhereUniqueInput
  }

  /**
   * tipos_documentos findFirst
   */
  export type tipos_documentosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipos_documentos
     */
    select?: tipos_documentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipos_documentos
     */
    omit?: tipos_documentosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipos_documentosInclude<ExtArgs> | null
    /**
     * Filter, which tipos_documentos to fetch.
     */
    where?: tipos_documentosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tipos_documentos to fetch.
     */
    orderBy?: tipos_documentosOrderByWithRelationInput | tipos_documentosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tipos_documentos.
     */
    cursor?: tipos_documentosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tipos_documentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tipos_documentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tipos_documentos.
     */
    distinct?: Tipos_documentosScalarFieldEnum | Tipos_documentosScalarFieldEnum[]
  }

  /**
   * tipos_documentos findFirstOrThrow
   */
  export type tipos_documentosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipos_documentos
     */
    select?: tipos_documentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipos_documentos
     */
    omit?: tipos_documentosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipos_documentosInclude<ExtArgs> | null
    /**
     * Filter, which tipos_documentos to fetch.
     */
    where?: tipos_documentosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tipos_documentos to fetch.
     */
    orderBy?: tipos_documentosOrderByWithRelationInput | tipos_documentosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tipos_documentos.
     */
    cursor?: tipos_documentosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tipos_documentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tipos_documentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tipos_documentos.
     */
    distinct?: Tipos_documentosScalarFieldEnum | Tipos_documentosScalarFieldEnum[]
  }

  /**
   * tipos_documentos findMany
   */
  export type tipos_documentosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipos_documentos
     */
    select?: tipos_documentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipos_documentos
     */
    omit?: tipos_documentosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipos_documentosInclude<ExtArgs> | null
    /**
     * Filter, which tipos_documentos to fetch.
     */
    where?: tipos_documentosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tipos_documentos to fetch.
     */
    orderBy?: tipos_documentosOrderByWithRelationInput | tipos_documentosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tipos_documentos.
     */
    cursor?: tipos_documentosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tipos_documentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tipos_documentos.
     */
    skip?: number
    distinct?: Tipos_documentosScalarFieldEnum | Tipos_documentosScalarFieldEnum[]
  }

  /**
   * tipos_documentos create
   */
  export type tipos_documentosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipos_documentos
     */
    select?: tipos_documentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipos_documentos
     */
    omit?: tipos_documentosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipos_documentosInclude<ExtArgs> | null
    /**
     * The data needed to create a tipos_documentos.
     */
    data?: XOR<tipos_documentosCreateInput, tipos_documentosUncheckedCreateInput>
  }

  /**
   * tipos_documentos createMany
   */
  export type tipos_documentosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tipos_documentos.
     */
    data: tipos_documentosCreateManyInput | tipos_documentosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tipos_documentos update
   */
  export type tipos_documentosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipos_documentos
     */
    select?: tipos_documentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipos_documentos
     */
    omit?: tipos_documentosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipos_documentosInclude<ExtArgs> | null
    /**
     * The data needed to update a tipos_documentos.
     */
    data: XOR<tipos_documentosUpdateInput, tipos_documentosUncheckedUpdateInput>
    /**
     * Choose, which tipos_documentos to update.
     */
    where: tipos_documentosWhereUniqueInput
  }

  /**
   * tipos_documentos updateMany
   */
  export type tipos_documentosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tipos_documentos.
     */
    data: XOR<tipos_documentosUpdateManyMutationInput, tipos_documentosUncheckedUpdateManyInput>
    /**
     * Filter which tipos_documentos to update
     */
    where?: tipos_documentosWhereInput
    /**
     * Limit how many tipos_documentos to update.
     */
    limit?: number
  }

  /**
   * tipos_documentos upsert
   */
  export type tipos_documentosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipos_documentos
     */
    select?: tipos_documentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipos_documentos
     */
    omit?: tipos_documentosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipos_documentosInclude<ExtArgs> | null
    /**
     * The filter to search for the tipos_documentos to update in case it exists.
     */
    where: tipos_documentosWhereUniqueInput
    /**
     * In case the tipos_documentos found by the `where` argument doesn't exist, create a new tipos_documentos with this data.
     */
    create: XOR<tipos_documentosCreateInput, tipos_documentosUncheckedCreateInput>
    /**
     * In case the tipos_documentos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tipos_documentosUpdateInput, tipos_documentosUncheckedUpdateInput>
  }

  /**
   * tipos_documentos delete
   */
  export type tipos_documentosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipos_documentos
     */
    select?: tipos_documentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipos_documentos
     */
    omit?: tipos_documentosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipos_documentosInclude<ExtArgs> | null
    /**
     * Filter which tipos_documentos to delete.
     */
    where: tipos_documentosWhereUniqueInput
  }

  /**
   * tipos_documentos deleteMany
   */
  export type tipos_documentosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tipos_documentos to delete
     */
    where?: tipos_documentosWhereInput
    /**
     * Limit how many tipos_documentos to delete.
     */
    limit?: number
  }

  /**
   * tipos_documentos.documentos
   */
  export type tipos_documentos$documentosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documentos
     */
    select?: documentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the documentos
     */
    omit?: documentosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: documentosInclude<ExtArgs> | null
    where?: documentosWhereInput
    orderBy?: documentosOrderByWithRelationInput | documentosOrderByWithRelationInput[]
    cursor?: documentosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentosScalarFieldEnum | DocumentosScalarFieldEnum[]
  }

  /**
   * tipos_documentos without action
   */
  export type tipos_documentosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipos_documentos
     */
    select?: tipos_documentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipos_documentos
     */
    omit?: tipos_documentosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipos_documentosInclude<ExtArgs> | null
  }


  /**
   * Model usuarios
   */

  export type AggregateUsuarios = {
    _count: UsuariosCountAggregateOutputType | null
    _avg: UsuariosAvgAggregateOutputType | null
    _sum: UsuariosSumAggregateOutputType | null
    _min: UsuariosMinAggregateOutputType | null
    _max: UsuariosMaxAggregateOutputType | null
  }

  export type UsuariosAvgAggregateOutputType = {
    id: number | null
    departamentos_id: number | null
    activo: number | null
  }

  export type UsuariosSumAggregateOutputType = {
    id: number | null
    departamentos_id: number | null
    activo: number | null
  }

  export type UsuariosMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    apellidos: string | null
    email: string | null
    password: string | null
    departamentos_id: number | null
    activo: number | null
  }

  export type UsuariosMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    apellidos: string | null
    email: string | null
    password: string | null
    departamentos_id: number | null
    activo: number | null
  }

  export type UsuariosCountAggregateOutputType = {
    id: number
    nombre: number
    apellidos: number
    email: number
    password: number
    departamentos_id: number
    activo: number
    _all: number
  }


  export type UsuariosAvgAggregateInputType = {
    id?: true
    departamentos_id?: true
    activo?: true
  }

  export type UsuariosSumAggregateInputType = {
    id?: true
    departamentos_id?: true
    activo?: true
  }

  export type UsuariosMinAggregateInputType = {
    id?: true
    nombre?: true
    apellidos?: true
    email?: true
    password?: true
    departamentos_id?: true
    activo?: true
  }

  export type UsuariosMaxAggregateInputType = {
    id?: true
    nombre?: true
    apellidos?: true
    email?: true
    password?: true
    departamentos_id?: true
    activo?: true
  }

  export type UsuariosCountAggregateInputType = {
    id?: true
    nombre?: true
    apellidos?: true
    email?: true
    password?: true
    departamentos_id?: true
    activo?: true
    _all?: true
  }

  export type UsuariosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which usuarios to aggregate.
     */
    where?: usuariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuarios to fetch.
     */
    orderBy?: usuariosOrderByWithRelationInput | usuariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usuariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned usuarios
    **/
    _count?: true | UsuariosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsuariosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsuariosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsuariosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsuariosMaxAggregateInputType
  }

  export type GetUsuariosAggregateType<T extends UsuariosAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuarios]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuarios[P]>
      : GetScalarType<T[P], AggregateUsuarios[P]>
  }




  export type usuariosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usuariosWhereInput
    orderBy?: usuariosOrderByWithAggregationInput | usuariosOrderByWithAggregationInput[]
    by: UsuariosScalarFieldEnum[] | UsuariosScalarFieldEnum
    having?: usuariosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsuariosCountAggregateInputType | true
    _avg?: UsuariosAvgAggregateInputType
    _sum?: UsuariosSumAggregateInputType
    _min?: UsuariosMinAggregateInputType
    _max?: UsuariosMaxAggregateInputType
  }

  export type UsuariosGroupByOutputType = {
    id: number
    nombre: string | null
    apellidos: string | null
    email: string | null
    password: string | null
    departamentos_id: number | null
    activo: number | null
    _count: UsuariosCountAggregateOutputType | null
    _avg: UsuariosAvgAggregateOutputType | null
    _sum: UsuariosSumAggregateOutputType | null
    _min: UsuariosMinAggregateOutputType | null
    _max: UsuariosMaxAggregateOutputType | null
  }

  type GetUsuariosGroupByPayload<T extends usuariosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsuariosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsuariosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuariosGroupByOutputType[P]>
            : GetScalarType<T[P], UsuariosGroupByOutputType[P]>
        }
      >
    >


  export type usuariosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    apellidos?: boolean
    email?: boolean
    password?: boolean
    departamentos_id?: boolean
    activo?: boolean
    documentos?: boolean | usuarios$documentosArgs<ExtArgs>
    usuarios_has_roles?: boolean | usuarios$usuarios_has_rolesArgs<ExtArgs>
    _count?: boolean | UsuariosCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuarios"]>



  export type usuariosSelectScalar = {
    id?: boolean
    nombre?: boolean
    apellidos?: boolean
    email?: boolean
    password?: boolean
    departamentos_id?: boolean
    activo?: boolean
  }

  export type usuariosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nombre" | "apellidos" | "email" | "password" | "departamentos_id" | "activo", ExtArgs["result"]["usuarios"]>
  export type usuariosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    documentos?: boolean | usuarios$documentosArgs<ExtArgs>
    usuarios_has_roles?: boolean | usuarios$usuarios_has_rolesArgs<ExtArgs>
    _count?: boolean | UsuariosCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $usuariosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "usuarios"
    objects: {
      documentos: Prisma.$documentosPayload<ExtArgs>[]
      usuarios_has_roles: Prisma.$usuarios_has_rolesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre: string | null
      apellidos: string | null
      email: string | null
      password: string | null
      departamentos_id: number | null
      activo: number | null
    }, ExtArgs["result"]["usuarios"]>
    composites: {}
  }

  type usuariosGetPayload<S extends boolean | null | undefined | usuariosDefaultArgs> = $Result.GetResult<Prisma.$usuariosPayload, S>

  type usuariosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<usuariosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsuariosCountAggregateInputType | true
    }

  export interface usuariosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['usuarios'], meta: { name: 'usuarios' } }
    /**
     * Find zero or one Usuarios that matches the filter.
     * @param {usuariosFindUniqueArgs} args - Arguments to find a Usuarios
     * @example
     * // Get one Usuarios
     * const usuarios = await prisma.usuarios.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usuariosFindUniqueArgs>(args: SelectSubset<T, usuariosFindUniqueArgs<ExtArgs>>): Prisma__usuariosClient<$Result.GetResult<Prisma.$usuariosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Usuarios that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {usuariosFindUniqueOrThrowArgs} args - Arguments to find a Usuarios
     * @example
     * // Get one Usuarios
     * const usuarios = await prisma.usuarios.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usuariosFindUniqueOrThrowArgs>(args: SelectSubset<T, usuariosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usuariosClient<$Result.GetResult<Prisma.$usuariosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuariosFindFirstArgs} args - Arguments to find a Usuarios
     * @example
     * // Get one Usuarios
     * const usuarios = await prisma.usuarios.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usuariosFindFirstArgs>(args?: SelectSubset<T, usuariosFindFirstArgs<ExtArgs>>): Prisma__usuariosClient<$Result.GetResult<Prisma.$usuariosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Usuarios that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuariosFindFirstOrThrowArgs} args - Arguments to find a Usuarios
     * @example
     * // Get one Usuarios
     * const usuarios = await prisma.usuarios.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usuariosFindFirstOrThrowArgs>(args?: SelectSubset<T, usuariosFindFirstOrThrowArgs<ExtArgs>>): Prisma__usuariosClient<$Result.GetResult<Prisma.$usuariosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuariosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usuarios
     * const usuarios = await prisma.usuarios.findMany()
     * 
     * // Get first 10 Usuarios
     * const usuarios = await prisma.usuarios.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usuariosWithIdOnly = await prisma.usuarios.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends usuariosFindManyArgs>(args?: SelectSubset<T, usuariosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usuariosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Usuarios.
     * @param {usuariosCreateArgs} args - Arguments to create a Usuarios.
     * @example
     * // Create one Usuarios
     * const Usuarios = await prisma.usuarios.create({
     *   data: {
     *     // ... data to create a Usuarios
     *   }
     * })
     * 
     */
    create<T extends usuariosCreateArgs>(args: SelectSubset<T, usuariosCreateArgs<ExtArgs>>): Prisma__usuariosClient<$Result.GetResult<Prisma.$usuariosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Usuarios.
     * @param {usuariosCreateManyArgs} args - Arguments to create many Usuarios.
     * @example
     * // Create many Usuarios
     * const usuarios = await prisma.usuarios.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usuariosCreateManyArgs>(args?: SelectSubset<T, usuariosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Usuarios.
     * @param {usuariosDeleteArgs} args - Arguments to delete one Usuarios.
     * @example
     * // Delete one Usuarios
     * const Usuarios = await prisma.usuarios.delete({
     *   where: {
     *     // ... filter to delete one Usuarios
     *   }
     * })
     * 
     */
    delete<T extends usuariosDeleteArgs>(args: SelectSubset<T, usuariosDeleteArgs<ExtArgs>>): Prisma__usuariosClient<$Result.GetResult<Prisma.$usuariosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Usuarios.
     * @param {usuariosUpdateArgs} args - Arguments to update one Usuarios.
     * @example
     * // Update one Usuarios
     * const usuarios = await prisma.usuarios.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usuariosUpdateArgs>(args: SelectSubset<T, usuariosUpdateArgs<ExtArgs>>): Prisma__usuariosClient<$Result.GetResult<Prisma.$usuariosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Usuarios.
     * @param {usuariosDeleteManyArgs} args - Arguments to filter Usuarios to delete.
     * @example
     * // Delete a few Usuarios
     * const { count } = await prisma.usuarios.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usuariosDeleteManyArgs>(args?: SelectSubset<T, usuariosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuariosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usuarios
     * const usuarios = await prisma.usuarios.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usuariosUpdateManyArgs>(args: SelectSubset<T, usuariosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Usuarios.
     * @param {usuariosUpsertArgs} args - Arguments to update or create a Usuarios.
     * @example
     * // Update or create a Usuarios
     * const usuarios = await prisma.usuarios.upsert({
     *   create: {
     *     // ... data to create a Usuarios
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usuarios we want to update
     *   }
     * })
     */
    upsert<T extends usuariosUpsertArgs>(args: SelectSubset<T, usuariosUpsertArgs<ExtArgs>>): Prisma__usuariosClient<$Result.GetResult<Prisma.$usuariosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuariosCountArgs} args - Arguments to filter Usuarios to count.
     * @example
     * // Count the number of Usuarios
     * const count = await prisma.usuarios.count({
     *   where: {
     *     // ... the filter for the Usuarios we want to count
     *   }
     * })
    **/
    count<T extends usuariosCountArgs>(
      args?: Subset<T, usuariosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuariosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuariosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsuariosAggregateArgs>(args: Subset<T, UsuariosAggregateArgs>): Prisma.PrismaPromise<GetUsuariosAggregateType<T>>

    /**
     * Group by Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuariosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usuariosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usuariosGroupByArgs['orderBy'] }
        : { orderBy?: usuariosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usuariosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuariosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the usuarios model
   */
  readonly fields: usuariosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for usuarios.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usuariosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    documentos<T extends usuarios$documentosArgs<ExtArgs> = {}>(args?: Subset<T, usuarios$documentosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$documentosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    usuarios_has_roles<T extends usuarios$usuarios_has_rolesArgs<ExtArgs> = {}>(args?: Subset<T, usuarios$usuarios_has_rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usuarios_has_rolesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the usuarios model
   */
  interface usuariosFieldRefs {
    readonly id: FieldRef<"usuarios", 'Int'>
    readonly nombre: FieldRef<"usuarios", 'String'>
    readonly apellidos: FieldRef<"usuarios", 'String'>
    readonly email: FieldRef<"usuarios", 'String'>
    readonly password: FieldRef<"usuarios", 'String'>
    readonly departamentos_id: FieldRef<"usuarios", 'Int'>
    readonly activo: FieldRef<"usuarios", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * usuarios findUnique
   */
  export type usuariosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuarios
     */
    select?: usuariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuarios
     */
    omit?: usuariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosInclude<ExtArgs> | null
    /**
     * Filter, which usuarios to fetch.
     */
    where: usuariosWhereUniqueInput
  }

  /**
   * usuarios findUniqueOrThrow
   */
  export type usuariosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuarios
     */
    select?: usuariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuarios
     */
    omit?: usuariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosInclude<ExtArgs> | null
    /**
     * Filter, which usuarios to fetch.
     */
    where: usuariosWhereUniqueInput
  }

  /**
   * usuarios findFirst
   */
  export type usuariosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuarios
     */
    select?: usuariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuarios
     */
    omit?: usuariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosInclude<ExtArgs> | null
    /**
     * Filter, which usuarios to fetch.
     */
    where?: usuariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuarios to fetch.
     */
    orderBy?: usuariosOrderByWithRelationInput | usuariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for usuarios.
     */
    cursor?: usuariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of usuarios.
     */
    distinct?: UsuariosScalarFieldEnum | UsuariosScalarFieldEnum[]
  }

  /**
   * usuarios findFirstOrThrow
   */
  export type usuariosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuarios
     */
    select?: usuariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuarios
     */
    omit?: usuariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosInclude<ExtArgs> | null
    /**
     * Filter, which usuarios to fetch.
     */
    where?: usuariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuarios to fetch.
     */
    orderBy?: usuariosOrderByWithRelationInput | usuariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for usuarios.
     */
    cursor?: usuariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of usuarios.
     */
    distinct?: UsuariosScalarFieldEnum | UsuariosScalarFieldEnum[]
  }

  /**
   * usuarios findMany
   */
  export type usuariosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuarios
     */
    select?: usuariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuarios
     */
    omit?: usuariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosInclude<ExtArgs> | null
    /**
     * Filter, which usuarios to fetch.
     */
    where?: usuariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuarios to fetch.
     */
    orderBy?: usuariosOrderByWithRelationInput | usuariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing usuarios.
     */
    cursor?: usuariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuarios.
     */
    skip?: number
    distinct?: UsuariosScalarFieldEnum | UsuariosScalarFieldEnum[]
  }

  /**
   * usuarios create
   */
  export type usuariosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuarios
     */
    select?: usuariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuarios
     */
    omit?: usuariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosInclude<ExtArgs> | null
    /**
     * The data needed to create a usuarios.
     */
    data?: XOR<usuariosCreateInput, usuariosUncheckedCreateInput>
  }

  /**
   * usuarios createMany
   */
  export type usuariosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many usuarios.
     */
    data: usuariosCreateManyInput | usuariosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * usuarios update
   */
  export type usuariosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuarios
     */
    select?: usuariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuarios
     */
    omit?: usuariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosInclude<ExtArgs> | null
    /**
     * The data needed to update a usuarios.
     */
    data: XOR<usuariosUpdateInput, usuariosUncheckedUpdateInput>
    /**
     * Choose, which usuarios to update.
     */
    where: usuariosWhereUniqueInput
  }

  /**
   * usuarios updateMany
   */
  export type usuariosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update usuarios.
     */
    data: XOR<usuariosUpdateManyMutationInput, usuariosUncheckedUpdateManyInput>
    /**
     * Filter which usuarios to update
     */
    where?: usuariosWhereInput
    /**
     * Limit how many usuarios to update.
     */
    limit?: number
  }

  /**
   * usuarios upsert
   */
  export type usuariosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuarios
     */
    select?: usuariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuarios
     */
    omit?: usuariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosInclude<ExtArgs> | null
    /**
     * The filter to search for the usuarios to update in case it exists.
     */
    where: usuariosWhereUniqueInput
    /**
     * In case the usuarios found by the `where` argument doesn't exist, create a new usuarios with this data.
     */
    create: XOR<usuariosCreateInput, usuariosUncheckedCreateInput>
    /**
     * In case the usuarios was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usuariosUpdateInput, usuariosUncheckedUpdateInput>
  }

  /**
   * usuarios delete
   */
  export type usuariosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuarios
     */
    select?: usuariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuarios
     */
    omit?: usuariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosInclude<ExtArgs> | null
    /**
     * Filter which usuarios to delete.
     */
    where: usuariosWhereUniqueInput
  }

  /**
   * usuarios deleteMany
   */
  export type usuariosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which usuarios to delete
     */
    where?: usuariosWhereInput
    /**
     * Limit how many usuarios to delete.
     */
    limit?: number
  }

  /**
   * usuarios.documentos
   */
  export type usuarios$documentosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documentos
     */
    select?: documentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the documentos
     */
    omit?: documentosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: documentosInclude<ExtArgs> | null
    where?: documentosWhereInput
    orderBy?: documentosOrderByWithRelationInput | documentosOrderByWithRelationInput[]
    cursor?: documentosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentosScalarFieldEnum | DocumentosScalarFieldEnum[]
  }

  /**
   * usuarios.usuarios_has_roles
   */
  export type usuarios$usuarios_has_rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuarios_has_roles
     */
    select?: usuarios_has_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuarios_has_roles
     */
    omit?: usuarios_has_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarios_has_rolesInclude<ExtArgs> | null
    where?: usuarios_has_rolesWhereInput
    orderBy?: usuarios_has_rolesOrderByWithRelationInput | usuarios_has_rolesOrderByWithRelationInput[]
    cursor?: usuarios_has_rolesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Usuarios_has_rolesScalarFieldEnum | Usuarios_has_rolesScalarFieldEnum[]
  }

  /**
   * usuarios without action
   */
  export type usuariosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuarios
     */
    select?: usuariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuarios
     */
    omit?: usuariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosInclude<ExtArgs> | null
  }


  /**
   * Model usuarios_has_roles
   */

  export type AggregateUsuarios_has_roles = {
    _count: Usuarios_has_rolesCountAggregateOutputType | null
    _avg: Usuarios_has_rolesAvgAggregateOutputType | null
    _sum: Usuarios_has_rolesSumAggregateOutputType | null
    _min: Usuarios_has_rolesMinAggregateOutputType | null
    _max: Usuarios_has_rolesMaxAggregateOutputType | null
  }

  export type Usuarios_has_rolesAvgAggregateOutputType = {
    usuarios_id: number | null
    roles_id: number | null
  }

  export type Usuarios_has_rolesSumAggregateOutputType = {
    usuarios_id: number | null
    roles_id: number | null
  }

  export type Usuarios_has_rolesMinAggregateOutputType = {
    usuarios_id: number | null
    roles_id: number | null
  }

  export type Usuarios_has_rolesMaxAggregateOutputType = {
    usuarios_id: number | null
    roles_id: number | null
  }

  export type Usuarios_has_rolesCountAggregateOutputType = {
    usuarios_id: number
    roles_id: number
    _all: number
  }


  export type Usuarios_has_rolesAvgAggregateInputType = {
    usuarios_id?: true
    roles_id?: true
  }

  export type Usuarios_has_rolesSumAggregateInputType = {
    usuarios_id?: true
    roles_id?: true
  }

  export type Usuarios_has_rolesMinAggregateInputType = {
    usuarios_id?: true
    roles_id?: true
  }

  export type Usuarios_has_rolesMaxAggregateInputType = {
    usuarios_id?: true
    roles_id?: true
  }

  export type Usuarios_has_rolesCountAggregateInputType = {
    usuarios_id?: true
    roles_id?: true
    _all?: true
  }

  export type Usuarios_has_rolesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which usuarios_has_roles to aggregate.
     */
    where?: usuarios_has_rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuarios_has_roles to fetch.
     */
    orderBy?: usuarios_has_rolesOrderByWithRelationInput | usuarios_has_rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usuarios_has_rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuarios_has_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuarios_has_roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned usuarios_has_roles
    **/
    _count?: true | Usuarios_has_rolesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Usuarios_has_rolesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Usuarios_has_rolesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Usuarios_has_rolesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Usuarios_has_rolesMaxAggregateInputType
  }

  export type GetUsuarios_has_rolesAggregateType<T extends Usuarios_has_rolesAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuarios_has_roles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuarios_has_roles[P]>
      : GetScalarType<T[P], AggregateUsuarios_has_roles[P]>
  }




  export type usuarios_has_rolesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usuarios_has_rolesWhereInput
    orderBy?: usuarios_has_rolesOrderByWithAggregationInput | usuarios_has_rolesOrderByWithAggregationInput[]
    by: Usuarios_has_rolesScalarFieldEnum[] | Usuarios_has_rolesScalarFieldEnum
    having?: usuarios_has_rolesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Usuarios_has_rolesCountAggregateInputType | true
    _avg?: Usuarios_has_rolesAvgAggregateInputType
    _sum?: Usuarios_has_rolesSumAggregateInputType
    _min?: Usuarios_has_rolesMinAggregateInputType
    _max?: Usuarios_has_rolesMaxAggregateInputType
  }

  export type Usuarios_has_rolesGroupByOutputType = {
    usuarios_id: number
    roles_id: number
    _count: Usuarios_has_rolesCountAggregateOutputType | null
    _avg: Usuarios_has_rolesAvgAggregateOutputType | null
    _sum: Usuarios_has_rolesSumAggregateOutputType | null
    _min: Usuarios_has_rolesMinAggregateOutputType | null
    _max: Usuarios_has_rolesMaxAggregateOutputType | null
  }

  type GetUsuarios_has_rolesGroupByPayload<T extends usuarios_has_rolesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Usuarios_has_rolesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Usuarios_has_rolesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Usuarios_has_rolesGroupByOutputType[P]>
            : GetScalarType<T[P], Usuarios_has_rolesGroupByOutputType[P]>
        }
      >
    >


  export type usuarios_has_rolesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    usuarios_id?: boolean
    roles_id?: boolean
    usuarios?: boolean | usuariosDefaultArgs<ExtArgs>
    roles?: boolean | rolesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuarios_has_roles"]>



  export type usuarios_has_rolesSelectScalar = {
    usuarios_id?: boolean
    roles_id?: boolean
  }

  export type usuarios_has_rolesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"usuarios_id" | "roles_id", ExtArgs["result"]["usuarios_has_roles"]>
  export type usuarios_has_rolesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuarios?: boolean | usuariosDefaultArgs<ExtArgs>
    roles?: boolean | rolesDefaultArgs<ExtArgs>
  }

  export type $usuarios_has_rolesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "usuarios_has_roles"
    objects: {
      usuarios: Prisma.$usuariosPayload<ExtArgs>
      roles: Prisma.$rolesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      usuarios_id: number
      roles_id: number
    }, ExtArgs["result"]["usuarios_has_roles"]>
    composites: {}
  }

  type usuarios_has_rolesGetPayload<S extends boolean | null | undefined | usuarios_has_rolesDefaultArgs> = $Result.GetResult<Prisma.$usuarios_has_rolesPayload, S>

  type usuarios_has_rolesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<usuarios_has_rolesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Usuarios_has_rolesCountAggregateInputType | true
    }

  export interface usuarios_has_rolesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['usuarios_has_roles'], meta: { name: 'usuarios_has_roles' } }
    /**
     * Find zero or one Usuarios_has_roles that matches the filter.
     * @param {usuarios_has_rolesFindUniqueArgs} args - Arguments to find a Usuarios_has_roles
     * @example
     * // Get one Usuarios_has_roles
     * const usuarios_has_roles = await prisma.usuarios_has_roles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usuarios_has_rolesFindUniqueArgs>(args: SelectSubset<T, usuarios_has_rolesFindUniqueArgs<ExtArgs>>): Prisma__usuarios_has_rolesClient<$Result.GetResult<Prisma.$usuarios_has_rolesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Usuarios_has_roles that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {usuarios_has_rolesFindUniqueOrThrowArgs} args - Arguments to find a Usuarios_has_roles
     * @example
     * // Get one Usuarios_has_roles
     * const usuarios_has_roles = await prisma.usuarios_has_roles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usuarios_has_rolesFindUniqueOrThrowArgs>(args: SelectSubset<T, usuarios_has_rolesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usuarios_has_rolesClient<$Result.GetResult<Prisma.$usuarios_has_rolesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Usuarios_has_roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuarios_has_rolesFindFirstArgs} args - Arguments to find a Usuarios_has_roles
     * @example
     * // Get one Usuarios_has_roles
     * const usuarios_has_roles = await prisma.usuarios_has_roles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usuarios_has_rolesFindFirstArgs>(args?: SelectSubset<T, usuarios_has_rolesFindFirstArgs<ExtArgs>>): Prisma__usuarios_has_rolesClient<$Result.GetResult<Prisma.$usuarios_has_rolesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Usuarios_has_roles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuarios_has_rolesFindFirstOrThrowArgs} args - Arguments to find a Usuarios_has_roles
     * @example
     * // Get one Usuarios_has_roles
     * const usuarios_has_roles = await prisma.usuarios_has_roles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usuarios_has_rolesFindFirstOrThrowArgs>(args?: SelectSubset<T, usuarios_has_rolesFindFirstOrThrowArgs<ExtArgs>>): Prisma__usuarios_has_rolesClient<$Result.GetResult<Prisma.$usuarios_has_rolesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Usuarios_has_roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuarios_has_rolesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usuarios_has_roles
     * const usuarios_has_roles = await prisma.usuarios_has_roles.findMany()
     * 
     * // Get first 10 Usuarios_has_roles
     * const usuarios_has_roles = await prisma.usuarios_has_roles.findMany({ take: 10 })
     * 
     * // Only select the `usuarios_id`
     * const usuarios_has_rolesWithUsuarios_idOnly = await prisma.usuarios_has_roles.findMany({ select: { usuarios_id: true } })
     * 
     */
    findMany<T extends usuarios_has_rolesFindManyArgs>(args?: SelectSubset<T, usuarios_has_rolesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usuarios_has_rolesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Usuarios_has_roles.
     * @param {usuarios_has_rolesCreateArgs} args - Arguments to create a Usuarios_has_roles.
     * @example
     * // Create one Usuarios_has_roles
     * const Usuarios_has_roles = await prisma.usuarios_has_roles.create({
     *   data: {
     *     // ... data to create a Usuarios_has_roles
     *   }
     * })
     * 
     */
    create<T extends usuarios_has_rolesCreateArgs>(args: SelectSubset<T, usuarios_has_rolesCreateArgs<ExtArgs>>): Prisma__usuarios_has_rolesClient<$Result.GetResult<Prisma.$usuarios_has_rolesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Usuarios_has_roles.
     * @param {usuarios_has_rolesCreateManyArgs} args - Arguments to create many Usuarios_has_roles.
     * @example
     * // Create many Usuarios_has_roles
     * const usuarios_has_roles = await prisma.usuarios_has_roles.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usuarios_has_rolesCreateManyArgs>(args?: SelectSubset<T, usuarios_has_rolesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Usuarios_has_roles.
     * @param {usuarios_has_rolesDeleteArgs} args - Arguments to delete one Usuarios_has_roles.
     * @example
     * // Delete one Usuarios_has_roles
     * const Usuarios_has_roles = await prisma.usuarios_has_roles.delete({
     *   where: {
     *     // ... filter to delete one Usuarios_has_roles
     *   }
     * })
     * 
     */
    delete<T extends usuarios_has_rolesDeleteArgs>(args: SelectSubset<T, usuarios_has_rolesDeleteArgs<ExtArgs>>): Prisma__usuarios_has_rolesClient<$Result.GetResult<Prisma.$usuarios_has_rolesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Usuarios_has_roles.
     * @param {usuarios_has_rolesUpdateArgs} args - Arguments to update one Usuarios_has_roles.
     * @example
     * // Update one Usuarios_has_roles
     * const usuarios_has_roles = await prisma.usuarios_has_roles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usuarios_has_rolesUpdateArgs>(args: SelectSubset<T, usuarios_has_rolesUpdateArgs<ExtArgs>>): Prisma__usuarios_has_rolesClient<$Result.GetResult<Prisma.$usuarios_has_rolesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Usuarios_has_roles.
     * @param {usuarios_has_rolesDeleteManyArgs} args - Arguments to filter Usuarios_has_roles to delete.
     * @example
     * // Delete a few Usuarios_has_roles
     * const { count } = await prisma.usuarios_has_roles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usuarios_has_rolesDeleteManyArgs>(args?: SelectSubset<T, usuarios_has_rolesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios_has_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuarios_has_rolesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usuarios_has_roles
     * const usuarios_has_roles = await prisma.usuarios_has_roles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usuarios_has_rolesUpdateManyArgs>(args: SelectSubset<T, usuarios_has_rolesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Usuarios_has_roles.
     * @param {usuarios_has_rolesUpsertArgs} args - Arguments to update or create a Usuarios_has_roles.
     * @example
     * // Update or create a Usuarios_has_roles
     * const usuarios_has_roles = await prisma.usuarios_has_roles.upsert({
     *   create: {
     *     // ... data to create a Usuarios_has_roles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usuarios_has_roles we want to update
     *   }
     * })
     */
    upsert<T extends usuarios_has_rolesUpsertArgs>(args: SelectSubset<T, usuarios_has_rolesUpsertArgs<ExtArgs>>): Prisma__usuarios_has_rolesClient<$Result.GetResult<Prisma.$usuarios_has_rolesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Usuarios_has_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuarios_has_rolesCountArgs} args - Arguments to filter Usuarios_has_roles to count.
     * @example
     * // Count the number of Usuarios_has_roles
     * const count = await prisma.usuarios_has_roles.count({
     *   where: {
     *     // ... the filter for the Usuarios_has_roles we want to count
     *   }
     * })
    **/
    count<T extends usuarios_has_rolesCountArgs>(
      args?: Subset<T, usuarios_has_rolesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Usuarios_has_rolesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usuarios_has_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Usuarios_has_rolesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Usuarios_has_rolesAggregateArgs>(args: Subset<T, Usuarios_has_rolesAggregateArgs>): Prisma.PrismaPromise<GetUsuarios_has_rolesAggregateType<T>>

    /**
     * Group by Usuarios_has_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuarios_has_rolesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usuarios_has_rolesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usuarios_has_rolesGroupByArgs['orderBy'] }
        : { orderBy?: usuarios_has_rolesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usuarios_has_rolesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuarios_has_rolesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the usuarios_has_roles model
   */
  readonly fields: usuarios_has_rolesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for usuarios_has_roles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usuarios_has_rolesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuarios<T extends usuariosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usuariosDefaultArgs<ExtArgs>>): Prisma__usuariosClient<$Result.GetResult<Prisma.$usuariosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    roles<T extends rolesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, rolesDefaultArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the usuarios_has_roles model
   */
  interface usuarios_has_rolesFieldRefs {
    readonly usuarios_id: FieldRef<"usuarios_has_roles", 'Int'>
    readonly roles_id: FieldRef<"usuarios_has_roles", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * usuarios_has_roles findUnique
   */
  export type usuarios_has_rolesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuarios_has_roles
     */
    select?: usuarios_has_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuarios_has_roles
     */
    omit?: usuarios_has_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarios_has_rolesInclude<ExtArgs> | null
    /**
     * Filter, which usuarios_has_roles to fetch.
     */
    where: usuarios_has_rolesWhereUniqueInput
  }

  /**
   * usuarios_has_roles findUniqueOrThrow
   */
  export type usuarios_has_rolesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuarios_has_roles
     */
    select?: usuarios_has_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuarios_has_roles
     */
    omit?: usuarios_has_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarios_has_rolesInclude<ExtArgs> | null
    /**
     * Filter, which usuarios_has_roles to fetch.
     */
    where: usuarios_has_rolesWhereUniqueInput
  }

  /**
   * usuarios_has_roles findFirst
   */
  export type usuarios_has_rolesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuarios_has_roles
     */
    select?: usuarios_has_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuarios_has_roles
     */
    omit?: usuarios_has_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarios_has_rolesInclude<ExtArgs> | null
    /**
     * Filter, which usuarios_has_roles to fetch.
     */
    where?: usuarios_has_rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuarios_has_roles to fetch.
     */
    orderBy?: usuarios_has_rolesOrderByWithRelationInput | usuarios_has_rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for usuarios_has_roles.
     */
    cursor?: usuarios_has_rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuarios_has_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuarios_has_roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of usuarios_has_roles.
     */
    distinct?: Usuarios_has_rolesScalarFieldEnum | Usuarios_has_rolesScalarFieldEnum[]
  }

  /**
   * usuarios_has_roles findFirstOrThrow
   */
  export type usuarios_has_rolesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuarios_has_roles
     */
    select?: usuarios_has_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuarios_has_roles
     */
    omit?: usuarios_has_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarios_has_rolesInclude<ExtArgs> | null
    /**
     * Filter, which usuarios_has_roles to fetch.
     */
    where?: usuarios_has_rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuarios_has_roles to fetch.
     */
    orderBy?: usuarios_has_rolesOrderByWithRelationInput | usuarios_has_rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for usuarios_has_roles.
     */
    cursor?: usuarios_has_rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuarios_has_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuarios_has_roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of usuarios_has_roles.
     */
    distinct?: Usuarios_has_rolesScalarFieldEnum | Usuarios_has_rolesScalarFieldEnum[]
  }

  /**
   * usuarios_has_roles findMany
   */
  export type usuarios_has_rolesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuarios_has_roles
     */
    select?: usuarios_has_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuarios_has_roles
     */
    omit?: usuarios_has_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarios_has_rolesInclude<ExtArgs> | null
    /**
     * Filter, which usuarios_has_roles to fetch.
     */
    where?: usuarios_has_rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuarios_has_roles to fetch.
     */
    orderBy?: usuarios_has_rolesOrderByWithRelationInput | usuarios_has_rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing usuarios_has_roles.
     */
    cursor?: usuarios_has_rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuarios_has_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuarios_has_roles.
     */
    skip?: number
    distinct?: Usuarios_has_rolesScalarFieldEnum | Usuarios_has_rolesScalarFieldEnum[]
  }

  /**
   * usuarios_has_roles create
   */
  export type usuarios_has_rolesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuarios_has_roles
     */
    select?: usuarios_has_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuarios_has_roles
     */
    omit?: usuarios_has_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarios_has_rolesInclude<ExtArgs> | null
    /**
     * The data needed to create a usuarios_has_roles.
     */
    data: XOR<usuarios_has_rolesCreateInput, usuarios_has_rolesUncheckedCreateInput>
  }

  /**
   * usuarios_has_roles createMany
   */
  export type usuarios_has_rolesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many usuarios_has_roles.
     */
    data: usuarios_has_rolesCreateManyInput | usuarios_has_rolesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * usuarios_has_roles update
   */
  export type usuarios_has_rolesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuarios_has_roles
     */
    select?: usuarios_has_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuarios_has_roles
     */
    omit?: usuarios_has_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarios_has_rolesInclude<ExtArgs> | null
    /**
     * The data needed to update a usuarios_has_roles.
     */
    data: XOR<usuarios_has_rolesUpdateInput, usuarios_has_rolesUncheckedUpdateInput>
    /**
     * Choose, which usuarios_has_roles to update.
     */
    where: usuarios_has_rolesWhereUniqueInput
  }

  /**
   * usuarios_has_roles updateMany
   */
  export type usuarios_has_rolesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update usuarios_has_roles.
     */
    data: XOR<usuarios_has_rolesUpdateManyMutationInput, usuarios_has_rolesUncheckedUpdateManyInput>
    /**
     * Filter which usuarios_has_roles to update
     */
    where?: usuarios_has_rolesWhereInput
    /**
     * Limit how many usuarios_has_roles to update.
     */
    limit?: number
  }

  /**
   * usuarios_has_roles upsert
   */
  export type usuarios_has_rolesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuarios_has_roles
     */
    select?: usuarios_has_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuarios_has_roles
     */
    omit?: usuarios_has_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarios_has_rolesInclude<ExtArgs> | null
    /**
     * The filter to search for the usuarios_has_roles to update in case it exists.
     */
    where: usuarios_has_rolesWhereUniqueInput
    /**
     * In case the usuarios_has_roles found by the `where` argument doesn't exist, create a new usuarios_has_roles with this data.
     */
    create: XOR<usuarios_has_rolesCreateInput, usuarios_has_rolesUncheckedCreateInput>
    /**
     * In case the usuarios_has_roles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usuarios_has_rolesUpdateInput, usuarios_has_rolesUncheckedUpdateInput>
  }

  /**
   * usuarios_has_roles delete
   */
  export type usuarios_has_rolesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuarios_has_roles
     */
    select?: usuarios_has_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuarios_has_roles
     */
    omit?: usuarios_has_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarios_has_rolesInclude<ExtArgs> | null
    /**
     * Filter which usuarios_has_roles to delete.
     */
    where: usuarios_has_rolesWhereUniqueInput
  }

  /**
   * usuarios_has_roles deleteMany
   */
  export type usuarios_has_rolesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which usuarios_has_roles to delete
     */
    where?: usuarios_has_rolesWhereInput
    /**
     * Limit how many usuarios_has_roles to delete.
     */
    limit?: number
  }

  /**
   * usuarios_has_roles without action
   */
  export type usuarios_has_rolesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuarios_has_roles
     */
    select?: usuarios_has_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuarios_has_roles
     */
    omit?: usuarios_has_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarios_has_rolesInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const BitacoraScalarFieldEnum: {
    id: 'id',
    usuario_id: 'usuario_id',
    rol: 'rol',
    accion: 'accion',
    ip: 'ip',
    descripcion: 'descripcion',
    fecha_inicio: 'fecha_inicio',
    fecha_act: 'fecha_act'
  };

  export type BitacoraScalarFieldEnum = (typeof BitacoraScalarFieldEnum)[keyof typeof BitacoraScalarFieldEnum]


  export const DepartamentosScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    descripcion: 'descripcion',
    activo: 'activo'
  };

  export type DepartamentosScalarFieldEnum = (typeof DepartamentosScalarFieldEnum)[keyof typeof DepartamentosScalarFieldEnum]


  export const DocumentosScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    descripcion: 'descripcion',
    mime: 'mime',
    ruta: 'ruta',
    tipos_documentos_id: 'tipos_documentos_id',
    usuarios_id: 'usuarios_id',
    fecha_subida: 'fecha_subida'
  };

  export type DocumentosScalarFieldEnum = (typeof DocumentosScalarFieldEnum)[keyof typeof DocumentosScalarFieldEnum]


  export const PeriodosScalarFieldEnum: {
    id: 'id',
    periodo: 'periodo',
    fecha_inicio: 'fecha_inicio',
    fecha_final: 'fecha_final',
    activo: 'activo'
  };

  export type PeriodosScalarFieldEnum = (typeof PeriodosScalarFieldEnum)[keyof typeof PeriodosScalarFieldEnum]


  export const ProcesosScalarFieldEnum: {
    id: 'id',
    estatus: 'estatus',
    resultado: 'resultado',
    fecha_inicio: 'fecha_inicio',
    fecha_fin: 'fecha_fin',
    departamentos_id: 'departamentos_id',
    periodos_id: 'periodos_id'
  };

  export type ProcesosScalarFieldEnum = (typeof ProcesosScalarFieldEnum)[keyof typeof ProcesosScalarFieldEnum]


  export const RolesScalarFieldEnum: {
    id: 'id',
    tipo: 'tipo',
    descripcion: 'descripcion',
    activo: 'activo',
    fecha_creacion: 'fecha_creacion'
  };

  export type RolesScalarFieldEnum = (typeof RolesScalarFieldEnum)[keyof typeof RolesScalarFieldEnum]


  export const Tipos_documentosScalarFieldEnum: {
    id: 'id',
    tipo: 'tipo'
  };

  export type Tipos_documentosScalarFieldEnum = (typeof Tipos_documentosScalarFieldEnum)[keyof typeof Tipos_documentosScalarFieldEnum]


  export const UsuariosScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    apellidos: 'apellidos',
    email: 'email',
    password: 'password',
    departamentos_id: 'departamentos_id',
    activo: 'activo'
  };

  export type UsuariosScalarFieldEnum = (typeof UsuariosScalarFieldEnum)[keyof typeof UsuariosScalarFieldEnum]


  export const Usuarios_has_rolesScalarFieldEnum: {
    usuarios_id: 'usuarios_id',
    roles_id: 'roles_id'
  };

  export type Usuarios_has_rolesScalarFieldEnum = (typeof Usuarios_has_rolesScalarFieldEnum)[keyof typeof Usuarios_has_rolesScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const bitacoraOrderByRelevanceFieldEnum: {
    rol: 'rol',
    accion: 'accion',
    ip: 'ip',
    descripcion: 'descripcion'
  };

  export type bitacoraOrderByRelevanceFieldEnum = (typeof bitacoraOrderByRelevanceFieldEnum)[keyof typeof bitacoraOrderByRelevanceFieldEnum]


  export const departamentosOrderByRelevanceFieldEnum: {
    nombre: 'nombre',
    descripcion: 'descripcion'
  };

  export type departamentosOrderByRelevanceFieldEnum = (typeof departamentosOrderByRelevanceFieldEnum)[keyof typeof departamentosOrderByRelevanceFieldEnum]


  export const documentosOrderByRelevanceFieldEnum: {
    nombre: 'nombre',
    descripcion: 'descripcion',
    mime: 'mime',
    ruta: 'ruta'
  };

  export type documentosOrderByRelevanceFieldEnum = (typeof documentosOrderByRelevanceFieldEnum)[keyof typeof documentosOrderByRelevanceFieldEnum]


  export const periodosOrderByRelevanceFieldEnum: {
    periodo: 'periodo'
  };

  export type periodosOrderByRelevanceFieldEnum = (typeof periodosOrderByRelevanceFieldEnum)[keyof typeof periodosOrderByRelevanceFieldEnum]


  export const rolesOrderByRelevanceFieldEnum: {
    descripcion: 'descripcion'
  };

  export type rolesOrderByRelevanceFieldEnum = (typeof rolesOrderByRelevanceFieldEnum)[keyof typeof rolesOrderByRelevanceFieldEnum]


  export const tipos_documentosOrderByRelevanceFieldEnum: {
    tipo: 'tipo'
  };

  export type tipos_documentosOrderByRelevanceFieldEnum = (typeof tipos_documentosOrderByRelevanceFieldEnum)[keyof typeof tipos_documentosOrderByRelevanceFieldEnum]


  export const usuariosOrderByRelevanceFieldEnum: {
    nombre: 'nombre',
    apellidos: 'apellidos',
    email: 'email',
    password: 'password'
  };

  export type usuariosOrderByRelevanceFieldEnum = (typeof usuariosOrderByRelevanceFieldEnum)[keyof typeof usuariosOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'procesos_estatus'
   */
  export type Enumprocesos_estatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'procesos_estatus'>
    


  /**
   * Reference to a field of type 'procesos_resultado'
   */
  export type Enumprocesos_resultadoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'procesos_resultado'>
    


  /**
   * Reference to a field of type 'roles_tipo'
   */
  export type Enumroles_tipoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'roles_tipo'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type bitacoraWhereInput = {
    AND?: bitacoraWhereInput | bitacoraWhereInput[]
    OR?: bitacoraWhereInput[]
    NOT?: bitacoraWhereInput | bitacoraWhereInput[]
    id?: IntFilter<"bitacora"> | number
    usuario_id?: IntNullableFilter<"bitacora"> | number | null
    rol?: StringNullableFilter<"bitacora"> | string | null
    accion?: StringNullableFilter<"bitacora"> | string | null
    ip?: StringNullableFilter<"bitacora"> | string | null
    descripcion?: StringNullableFilter<"bitacora"> | string | null
    fecha_inicio?: DateTimeNullableFilter<"bitacora"> | Date | string | null
    fecha_act?: DateTimeNullableFilter<"bitacora"> | Date | string | null
  }

  export type bitacoraOrderByWithRelationInput = {
    id?: SortOrder
    usuario_id?: SortOrderInput | SortOrder
    rol?: SortOrderInput | SortOrder
    accion?: SortOrderInput | SortOrder
    ip?: SortOrderInput | SortOrder
    descripcion?: SortOrderInput | SortOrder
    fecha_inicio?: SortOrderInput | SortOrder
    fecha_act?: SortOrderInput | SortOrder
    _relevance?: bitacoraOrderByRelevanceInput
  }

  export type bitacoraWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: bitacoraWhereInput | bitacoraWhereInput[]
    OR?: bitacoraWhereInput[]
    NOT?: bitacoraWhereInput | bitacoraWhereInput[]
    usuario_id?: IntNullableFilter<"bitacora"> | number | null
    rol?: StringNullableFilter<"bitacora"> | string | null
    accion?: StringNullableFilter<"bitacora"> | string | null
    ip?: StringNullableFilter<"bitacora"> | string | null
    descripcion?: StringNullableFilter<"bitacora"> | string | null
    fecha_inicio?: DateTimeNullableFilter<"bitacora"> | Date | string | null
    fecha_act?: DateTimeNullableFilter<"bitacora"> | Date | string | null
  }, "id">

  export type bitacoraOrderByWithAggregationInput = {
    id?: SortOrder
    usuario_id?: SortOrderInput | SortOrder
    rol?: SortOrderInput | SortOrder
    accion?: SortOrderInput | SortOrder
    ip?: SortOrderInput | SortOrder
    descripcion?: SortOrderInput | SortOrder
    fecha_inicio?: SortOrderInput | SortOrder
    fecha_act?: SortOrderInput | SortOrder
    _count?: bitacoraCountOrderByAggregateInput
    _avg?: bitacoraAvgOrderByAggregateInput
    _max?: bitacoraMaxOrderByAggregateInput
    _min?: bitacoraMinOrderByAggregateInput
    _sum?: bitacoraSumOrderByAggregateInput
  }

  export type bitacoraScalarWhereWithAggregatesInput = {
    AND?: bitacoraScalarWhereWithAggregatesInput | bitacoraScalarWhereWithAggregatesInput[]
    OR?: bitacoraScalarWhereWithAggregatesInput[]
    NOT?: bitacoraScalarWhereWithAggregatesInput | bitacoraScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"bitacora"> | number
    usuario_id?: IntNullableWithAggregatesFilter<"bitacora"> | number | null
    rol?: StringNullableWithAggregatesFilter<"bitacora"> | string | null
    accion?: StringNullableWithAggregatesFilter<"bitacora"> | string | null
    ip?: StringNullableWithAggregatesFilter<"bitacora"> | string | null
    descripcion?: StringNullableWithAggregatesFilter<"bitacora"> | string | null
    fecha_inicio?: DateTimeNullableWithAggregatesFilter<"bitacora"> | Date | string | null
    fecha_act?: DateTimeNullableWithAggregatesFilter<"bitacora"> | Date | string | null
  }

  export type departamentosWhereInput = {
    AND?: departamentosWhereInput | departamentosWhereInput[]
    OR?: departamentosWhereInput[]
    NOT?: departamentosWhereInput | departamentosWhereInput[]
    id?: IntFilter<"departamentos"> | number
    nombre?: StringNullableFilter<"departamentos"> | string | null
    descripcion?: StringNullableFilter<"departamentos"> | string | null
    activo?: BoolNullableFilter<"departamentos"> | boolean | null
  }

  export type departamentosOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrderInput | SortOrder
    descripcion?: SortOrderInput | SortOrder
    activo?: SortOrderInput | SortOrder
    _relevance?: departamentosOrderByRelevanceInput
  }

  export type departamentosWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: departamentosWhereInput | departamentosWhereInput[]
    OR?: departamentosWhereInput[]
    NOT?: departamentosWhereInput | departamentosWhereInput[]
    nombre?: StringNullableFilter<"departamentos"> | string | null
    descripcion?: StringNullableFilter<"departamentos"> | string | null
    activo?: BoolNullableFilter<"departamentos"> | boolean | null
  }, "id">

  export type departamentosOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrderInput | SortOrder
    descripcion?: SortOrderInput | SortOrder
    activo?: SortOrderInput | SortOrder
    _count?: departamentosCountOrderByAggregateInput
    _avg?: departamentosAvgOrderByAggregateInput
    _max?: departamentosMaxOrderByAggregateInput
    _min?: departamentosMinOrderByAggregateInput
    _sum?: departamentosSumOrderByAggregateInput
  }

  export type departamentosScalarWhereWithAggregatesInput = {
    AND?: departamentosScalarWhereWithAggregatesInput | departamentosScalarWhereWithAggregatesInput[]
    OR?: departamentosScalarWhereWithAggregatesInput[]
    NOT?: departamentosScalarWhereWithAggregatesInput | departamentosScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"departamentos"> | number
    nombre?: StringNullableWithAggregatesFilter<"departamentos"> | string | null
    descripcion?: StringNullableWithAggregatesFilter<"departamentos"> | string | null
    activo?: BoolNullableWithAggregatesFilter<"departamentos"> | boolean | null
  }

  export type documentosWhereInput = {
    AND?: documentosWhereInput | documentosWhereInput[]
    OR?: documentosWhereInput[]
    NOT?: documentosWhereInput | documentosWhereInput[]
    id?: IntFilter<"documentos"> | number
    nombre?: StringNullableFilter<"documentos"> | string | null
    descripcion?: StringNullableFilter<"documentos"> | string | null
    mime?: StringNullableFilter<"documentos"> | string | null
    ruta?: StringNullableFilter<"documentos"> | string | null
    tipos_documentos_id?: IntNullableFilter<"documentos"> | number | null
    usuarios_id?: IntNullableFilter<"documentos"> | number | null
    fecha_subida?: DateTimeNullableFilter<"documentos"> | Date | string | null
    tipos_documentos?: XOR<Tipos_documentosNullableScalarRelationFilter, tipos_documentosWhereInput> | null
    usuarios?: XOR<UsuariosNullableScalarRelationFilter, usuariosWhereInput> | null
  }

  export type documentosOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrderInput | SortOrder
    descripcion?: SortOrderInput | SortOrder
    mime?: SortOrderInput | SortOrder
    ruta?: SortOrderInput | SortOrder
    tipos_documentos_id?: SortOrderInput | SortOrder
    usuarios_id?: SortOrderInput | SortOrder
    fecha_subida?: SortOrderInput | SortOrder
    tipos_documentos?: tipos_documentosOrderByWithRelationInput
    usuarios?: usuariosOrderByWithRelationInput
    _relevance?: documentosOrderByRelevanceInput
  }

  export type documentosWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: documentosWhereInput | documentosWhereInput[]
    OR?: documentosWhereInput[]
    NOT?: documentosWhereInput | documentosWhereInput[]
    nombre?: StringNullableFilter<"documentos"> | string | null
    descripcion?: StringNullableFilter<"documentos"> | string | null
    mime?: StringNullableFilter<"documentos"> | string | null
    ruta?: StringNullableFilter<"documentos"> | string | null
    tipos_documentos_id?: IntNullableFilter<"documentos"> | number | null
    usuarios_id?: IntNullableFilter<"documentos"> | number | null
    fecha_subida?: DateTimeNullableFilter<"documentos"> | Date | string | null
    tipos_documentos?: XOR<Tipos_documentosNullableScalarRelationFilter, tipos_documentosWhereInput> | null
    usuarios?: XOR<UsuariosNullableScalarRelationFilter, usuariosWhereInput> | null
  }, "id">

  export type documentosOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrderInput | SortOrder
    descripcion?: SortOrderInput | SortOrder
    mime?: SortOrderInput | SortOrder
    ruta?: SortOrderInput | SortOrder
    tipos_documentos_id?: SortOrderInput | SortOrder
    usuarios_id?: SortOrderInput | SortOrder
    fecha_subida?: SortOrderInput | SortOrder
    _count?: documentosCountOrderByAggregateInput
    _avg?: documentosAvgOrderByAggregateInput
    _max?: documentosMaxOrderByAggregateInput
    _min?: documentosMinOrderByAggregateInput
    _sum?: documentosSumOrderByAggregateInput
  }

  export type documentosScalarWhereWithAggregatesInput = {
    AND?: documentosScalarWhereWithAggregatesInput | documentosScalarWhereWithAggregatesInput[]
    OR?: documentosScalarWhereWithAggregatesInput[]
    NOT?: documentosScalarWhereWithAggregatesInput | documentosScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"documentos"> | number
    nombre?: StringNullableWithAggregatesFilter<"documentos"> | string | null
    descripcion?: StringNullableWithAggregatesFilter<"documentos"> | string | null
    mime?: StringNullableWithAggregatesFilter<"documentos"> | string | null
    ruta?: StringNullableWithAggregatesFilter<"documentos"> | string | null
    tipos_documentos_id?: IntNullableWithAggregatesFilter<"documentos"> | number | null
    usuarios_id?: IntNullableWithAggregatesFilter<"documentos"> | number | null
    fecha_subida?: DateTimeNullableWithAggregatesFilter<"documentos"> | Date | string | null
  }

  export type periodosWhereInput = {
    AND?: periodosWhereInput | periodosWhereInput[]
    OR?: periodosWhereInput[]
    NOT?: periodosWhereInput | periodosWhereInput[]
    id?: IntFilter<"periodos"> | number
    periodo?: StringNullableFilter<"periodos"> | string | null
    fecha_inicio?: DateTimeNullableFilter<"periodos"> | Date | string | null
    fecha_final?: DateTimeNullableFilter<"periodos"> | Date | string | null
    activo?: BoolNullableFilter<"periodos"> | boolean | null
  }

  export type periodosOrderByWithRelationInput = {
    id?: SortOrder
    periodo?: SortOrderInput | SortOrder
    fecha_inicio?: SortOrderInput | SortOrder
    fecha_final?: SortOrderInput | SortOrder
    activo?: SortOrderInput | SortOrder
    _relevance?: periodosOrderByRelevanceInput
  }

  export type periodosWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: periodosWhereInput | periodosWhereInput[]
    OR?: periodosWhereInput[]
    NOT?: periodosWhereInput | periodosWhereInput[]
    periodo?: StringNullableFilter<"periodos"> | string | null
    fecha_inicio?: DateTimeNullableFilter<"periodos"> | Date | string | null
    fecha_final?: DateTimeNullableFilter<"periodos"> | Date | string | null
    activo?: BoolNullableFilter<"periodos"> | boolean | null
  }, "id">

  export type periodosOrderByWithAggregationInput = {
    id?: SortOrder
    periodo?: SortOrderInput | SortOrder
    fecha_inicio?: SortOrderInput | SortOrder
    fecha_final?: SortOrderInput | SortOrder
    activo?: SortOrderInput | SortOrder
    _count?: periodosCountOrderByAggregateInput
    _avg?: periodosAvgOrderByAggregateInput
    _max?: periodosMaxOrderByAggregateInput
    _min?: periodosMinOrderByAggregateInput
    _sum?: periodosSumOrderByAggregateInput
  }

  export type periodosScalarWhereWithAggregatesInput = {
    AND?: periodosScalarWhereWithAggregatesInput | periodosScalarWhereWithAggregatesInput[]
    OR?: periodosScalarWhereWithAggregatesInput[]
    NOT?: periodosScalarWhereWithAggregatesInput | periodosScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"periodos"> | number
    periodo?: StringNullableWithAggregatesFilter<"periodos"> | string | null
    fecha_inicio?: DateTimeNullableWithAggregatesFilter<"periodos"> | Date | string | null
    fecha_final?: DateTimeNullableWithAggregatesFilter<"periodos"> | Date | string | null
    activo?: BoolNullableWithAggregatesFilter<"periodos"> | boolean | null
  }

  export type procesosWhereInput = {
    AND?: procesosWhereInput | procesosWhereInput[]
    OR?: procesosWhereInput[]
    NOT?: procesosWhereInput | procesosWhereInput[]
    id?: IntFilter<"procesos"> | number
    estatus?: Enumprocesos_estatusFilter<"procesos"> | $Enums.procesos_estatus
    resultado?: Enumprocesos_resultadoNullableFilter<"procesos"> | $Enums.procesos_resultado | null
    fecha_inicio?: DateTimeNullableFilter<"procesos"> | Date | string | null
    fecha_fin?: DateTimeNullableFilter<"procesos"> | Date | string | null
    departamentos_id?: IntNullableFilter<"procesos"> | number | null
    periodos_id?: IntNullableFilter<"procesos"> | number | null
  }

  export type procesosOrderByWithRelationInput = {
    id?: SortOrder
    estatus?: SortOrder
    resultado?: SortOrderInput | SortOrder
    fecha_inicio?: SortOrderInput | SortOrder
    fecha_fin?: SortOrderInput | SortOrder
    departamentos_id?: SortOrderInput | SortOrder
    periodos_id?: SortOrderInput | SortOrder
  }

  export type procesosWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: procesosWhereInput | procesosWhereInput[]
    OR?: procesosWhereInput[]
    NOT?: procesosWhereInput | procesosWhereInput[]
    estatus?: Enumprocesos_estatusFilter<"procesos"> | $Enums.procesos_estatus
    resultado?: Enumprocesos_resultadoNullableFilter<"procesos"> | $Enums.procesos_resultado | null
    fecha_inicio?: DateTimeNullableFilter<"procesos"> | Date | string | null
    fecha_fin?: DateTimeNullableFilter<"procesos"> | Date | string | null
    departamentos_id?: IntNullableFilter<"procesos"> | number | null
    periodos_id?: IntNullableFilter<"procesos"> | number | null
  }, "id">

  export type procesosOrderByWithAggregationInput = {
    id?: SortOrder
    estatus?: SortOrder
    resultado?: SortOrderInput | SortOrder
    fecha_inicio?: SortOrderInput | SortOrder
    fecha_fin?: SortOrderInput | SortOrder
    departamentos_id?: SortOrderInput | SortOrder
    periodos_id?: SortOrderInput | SortOrder
    _count?: procesosCountOrderByAggregateInput
    _avg?: procesosAvgOrderByAggregateInput
    _max?: procesosMaxOrderByAggregateInput
    _min?: procesosMinOrderByAggregateInput
    _sum?: procesosSumOrderByAggregateInput
  }

  export type procesosScalarWhereWithAggregatesInput = {
    AND?: procesosScalarWhereWithAggregatesInput | procesosScalarWhereWithAggregatesInput[]
    OR?: procesosScalarWhereWithAggregatesInput[]
    NOT?: procesosScalarWhereWithAggregatesInput | procesosScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"procesos"> | number
    estatus?: Enumprocesos_estatusWithAggregatesFilter<"procesos"> | $Enums.procesos_estatus
    resultado?: Enumprocesos_resultadoNullableWithAggregatesFilter<"procesos"> | $Enums.procesos_resultado | null
    fecha_inicio?: DateTimeNullableWithAggregatesFilter<"procesos"> | Date | string | null
    fecha_fin?: DateTimeNullableWithAggregatesFilter<"procesos"> | Date | string | null
    departamentos_id?: IntNullableWithAggregatesFilter<"procesos"> | number | null
    periodos_id?: IntNullableWithAggregatesFilter<"procesos"> | number | null
  }

  export type rolesWhereInput = {
    AND?: rolesWhereInput | rolesWhereInput[]
    OR?: rolesWhereInput[]
    NOT?: rolesWhereInput | rolesWhereInput[]
    id?: IntFilter<"roles"> | number
    tipo?: Enumroles_tipoFilter<"roles"> | $Enums.roles_tipo
    descripcion?: StringNullableFilter<"roles"> | string | null
    activo?: BoolNullableFilter<"roles"> | boolean | null
    fecha_creacion?: DateTimeNullableFilter<"roles"> | Date | string | null
    usuarios_has_roles?: Usuarios_has_rolesListRelationFilter
  }

  export type rolesOrderByWithRelationInput = {
    id?: SortOrder
    tipo?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    activo?: SortOrderInput | SortOrder
    fecha_creacion?: SortOrderInput | SortOrder
    usuarios_has_roles?: usuarios_has_rolesOrderByRelationAggregateInput
    _relevance?: rolesOrderByRelevanceInput
  }

  export type rolesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: rolesWhereInput | rolesWhereInput[]
    OR?: rolesWhereInput[]
    NOT?: rolesWhereInput | rolesWhereInput[]
    tipo?: Enumroles_tipoFilter<"roles"> | $Enums.roles_tipo
    descripcion?: StringNullableFilter<"roles"> | string | null
    activo?: BoolNullableFilter<"roles"> | boolean | null
    fecha_creacion?: DateTimeNullableFilter<"roles"> | Date | string | null
    usuarios_has_roles?: Usuarios_has_rolesListRelationFilter
  }, "id">

  export type rolesOrderByWithAggregationInput = {
    id?: SortOrder
    tipo?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    activo?: SortOrderInput | SortOrder
    fecha_creacion?: SortOrderInput | SortOrder
    _count?: rolesCountOrderByAggregateInput
    _avg?: rolesAvgOrderByAggregateInput
    _max?: rolesMaxOrderByAggregateInput
    _min?: rolesMinOrderByAggregateInput
    _sum?: rolesSumOrderByAggregateInput
  }

  export type rolesScalarWhereWithAggregatesInput = {
    AND?: rolesScalarWhereWithAggregatesInput | rolesScalarWhereWithAggregatesInput[]
    OR?: rolesScalarWhereWithAggregatesInput[]
    NOT?: rolesScalarWhereWithAggregatesInput | rolesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"roles"> | number
    tipo?: Enumroles_tipoWithAggregatesFilter<"roles"> | $Enums.roles_tipo
    descripcion?: StringNullableWithAggregatesFilter<"roles"> | string | null
    activo?: BoolNullableWithAggregatesFilter<"roles"> | boolean | null
    fecha_creacion?: DateTimeNullableWithAggregatesFilter<"roles"> | Date | string | null
  }

  export type tipos_documentosWhereInput = {
    AND?: tipos_documentosWhereInput | tipos_documentosWhereInput[]
    OR?: tipos_documentosWhereInput[]
    NOT?: tipos_documentosWhereInput | tipos_documentosWhereInput[]
    id?: IntFilter<"tipos_documentos"> | number
    tipo?: StringNullableFilter<"tipos_documentos"> | string | null
    documentos?: DocumentosListRelationFilter
  }

  export type tipos_documentosOrderByWithRelationInput = {
    id?: SortOrder
    tipo?: SortOrderInput | SortOrder
    documentos?: documentosOrderByRelationAggregateInput
    _relevance?: tipos_documentosOrderByRelevanceInput
  }

  export type tipos_documentosWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: tipos_documentosWhereInput | tipos_documentosWhereInput[]
    OR?: tipos_documentosWhereInput[]
    NOT?: tipos_documentosWhereInput | tipos_documentosWhereInput[]
    tipo?: StringNullableFilter<"tipos_documentos"> | string | null
    documentos?: DocumentosListRelationFilter
  }, "id">

  export type tipos_documentosOrderByWithAggregationInput = {
    id?: SortOrder
    tipo?: SortOrderInput | SortOrder
    _count?: tipos_documentosCountOrderByAggregateInput
    _avg?: tipos_documentosAvgOrderByAggregateInput
    _max?: tipos_documentosMaxOrderByAggregateInput
    _min?: tipos_documentosMinOrderByAggregateInput
    _sum?: tipos_documentosSumOrderByAggregateInput
  }

  export type tipos_documentosScalarWhereWithAggregatesInput = {
    AND?: tipos_documentosScalarWhereWithAggregatesInput | tipos_documentosScalarWhereWithAggregatesInput[]
    OR?: tipos_documentosScalarWhereWithAggregatesInput[]
    NOT?: tipos_documentosScalarWhereWithAggregatesInput | tipos_documentosScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"tipos_documentos"> | number
    tipo?: StringNullableWithAggregatesFilter<"tipos_documentos"> | string | null
  }

  export type usuariosWhereInput = {
    AND?: usuariosWhereInput | usuariosWhereInput[]
    OR?: usuariosWhereInput[]
    NOT?: usuariosWhereInput | usuariosWhereInput[]
    id?: IntFilter<"usuarios"> | number
    nombre?: StringNullableFilter<"usuarios"> | string | null
    apellidos?: StringNullableFilter<"usuarios"> | string | null
    email?: StringNullableFilter<"usuarios"> | string | null
    password?: StringNullableFilter<"usuarios"> | string | null
    departamentos_id?: IntNullableFilter<"usuarios"> | number | null
    activo?: IntNullableFilter<"usuarios"> | number | null
    documentos?: DocumentosListRelationFilter
    usuarios_has_roles?: Usuarios_has_rolesListRelationFilter
  }

  export type usuariosOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrderInput | SortOrder
    apellidos?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    departamentos_id?: SortOrderInput | SortOrder
    activo?: SortOrderInput | SortOrder
    documentos?: documentosOrderByRelationAggregateInput
    usuarios_has_roles?: usuarios_has_rolesOrderByRelationAggregateInput
    _relevance?: usuariosOrderByRelevanceInput
  }

  export type usuariosWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: usuariosWhereInput | usuariosWhereInput[]
    OR?: usuariosWhereInput[]
    NOT?: usuariosWhereInput | usuariosWhereInput[]
    nombre?: StringNullableFilter<"usuarios"> | string | null
    apellidos?: StringNullableFilter<"usuarios"> | string | null
    password?: StringNullableFilter<"usuarios"> | string | null
    departamentos_id?: IntNullableFilter<"usuarios"> | number | null
    activo?: IntNullableFilter<"usuarios"> | number | null
    documentos?: DocumentosListRelationFilter
    usuarios_has_roles?: Usuarios_has_rolesListRelationFilter
  }, "id" | "email">

  export type usuariosOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrderInput | SortOrder
    apellidos?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    departamentos_id?: SortOrderInput | SortOrder
    activo?: SortOrderInput | SortOrder
    _count?: usuariosCountOrderByAggregateInput
    _avg?: usuariosAvgOrderByAggregateInput
    _max?: usuariosMaxOrderByAggregateInput
    _min?: usuariosMinOrderByAggregateInput
    _sum?: usuariosSumOrderByAggregateInput
  }

  export type usuariosScalarWhereWithAggregatesInput = {
    AND?: usuariosScalarWhereWithAggregatesInput | usuariosScalarWhereWithAggregatesInput[]
    OR?: usuariosScalarWhereWithAggregatesInput[]
    NOT?: usuariosScalarWhereWithAggregatesInput | usuariosScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"usuarios"> | number
    nombre?: StringNullableWithAggregatesFilter<"usuarios"> | string | null
    apellidos?: StringNullableWithAggregatesFilter<"usuarios"> | string | null
    email?: StringNullableWithAggregatesFilter<"usuarios"> | string | null
    password?: StringNullableWithAggregatesFilter<"usuarios"> | string | null
    departamentos_id?: IntNullableWithAggregatesFilter<"usuarios"> | number | null
    activo?: IntNullableWithAggregatesFilter<"usuarios"> | number | null
  }

  export type usuarios_has_rolesWhereInput = {
    AND?: usuarios_has_rolesWhereInput | usuarios_has_rolesWhereInput[]
    OR?: usuarios_has_rolesWhereInput[]
    NOT?: usuarios_has_rolesWhereInput | usuarios_has_rolesWhereInput[]
    usuarios_id?: IntFilter<"usuarios_has_roles"> | number
    roles_id?: IntFilter<"usuarios_has_roles"> | number
    usuarios?: XOR<UsuariosScalarRelationFilter, usuariosWhereInput>
    roles?: XOR<RolesScalarRelationFilter, rolesWhereInput>
  }

  export type usuarios_has_rolesOrderByWithRelationInput = {
    usuarios_id?: SortOrder
    roles_id?: SortOrder
    usuarios?: usuariosOrderByWithRelationInput
    roles?: rolesOrderByWithRelationInput
  }

  export type usuarios_has_rolesWhereUniqueInput = Prisma.AtLeast<{
    usuarios_id_roles_id?: usuarios_has_rolesUsuarios_idRoles_idCompoundUniqueInput
    AND?: usuarios_has_rolesWhereInput | usuarios_has_rolesWhereInput[]
    OR?: usuarios_has_rolesWhereInput[]
    NOT?: usuarios_has_rolesWhereInput | usuarios_has_rolesWhereInput[]
    usuarios_id?: IntFilter<"usuarios_has_roles"> | number
    roles_id?: IntFilter<"usuarios_has_roles"> | number
    usuarios?: XOR<UsuariosScalarRelationFilter, usuariosWhereInput>
    roles?: XOR<RolesScalarRelationFilter, rolesWhereInput>
  }, "usuarios_id_roles_id">

  export type usuarios_has_rolesOrderByWithAggregationInput = {
    usuarios_id?: SortOrder
    roles_id?: SortOrder
    _count?: usuarios_has_rolesCountOrderByAggregateInput
    _avg?: usuarios_has_rolesAvgOrderByAggregateInput
    _max?: usuarios_has_rolesMaxOrderByAggregateInput
    _min?: usuarios_has_rolesMinOrderByAggregateInput
    _sum?: usuarios_has_rolesSumOrderByAggregateInput
  }

  export type usuarios_has_rolesScalarWhereWithAggregatesInput = {
    AND?: usuarios_has_rolesScalarWhereWithAggregatesInput | usuarios_has_rolesScalarWhereWithAggregatesInput[]
    OR?: usuarios_has_rolesScalarWhereWithAggregatesInput[]
    NOT?: usuarios_has_rolesScalarWhereWithAggregatesInput | usuarios_has_rolesScalarWhereWithAggregatesInput[]
    usuarios_id?: IntWithAggregatesFilter<"usuarios_has_roles"> | number
    roles_id?: IntWithAggregatesFilter<"usuarios_has_roles"> | number
  }

  export type bitacoraCreateInput = {
    usuario_id?: number | null
    rol?: string | null
    accion?: string | null
    ip?: string | null
    descripcion?: string | null
    fecha_inicio?: Date | string | null
    fecha_act?: Date | string | null
  }

  export type bitacoraUncheckedCreateInput = {
    id?: number
    usuario_id?: number | null
    rol?: string | null
    accion?: string | null
    ip?: string | null
    descripcion?: string | null
    fecha_inicio?: Date | string | null
    fecha_act?: Date | string | null
  }

  export type bitacoraUpdateInput = {
    usuario_id?: NullableIntFieldUpdateOperationsInput | number | null
    rol?: NullableStringFieldUpdateOperationsInput | string | null
    accion?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_act?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type bitacoraUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuario_id?: NullableIntFieldUpdateOperationsInput | number | null
    rol?: NullableStringFieldUpdateOperationsInput | string | null
    accion?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_act?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type bitacoraCreateManyInput = {
    id?: number
    usuario_id?: number | null
    rol?: string | null
    accion?: string | null
    ip?: string | null
    descripcion?: string | null
    fecha_inicio?: Date | string | null
    fecha_act?: Date | string | null
  }

  export type bitacoraUpdateManyMutationInput = {
    usuario_id?: NullableIntFieldUpdateOperationsInput | number | null
    rol?: NullableStringFieldUpdateOperationsInput | string | null
    accion?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_act?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type bitacoraUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuario_id?: NullableIntFieldUpdateOperationsInput | number | null
    rol?: NullableStringFieldUpdateOperationsInput | string | null
    accion?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_act?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type departamentosCreateInput = {
    nombre?: string | null
    descripcion?: string | null
    activo?: boolean | null
  }

  export type departamentosUncheckedCreateInput = {
    id?: number
    nombre?: string | null
    descripcion?: string | null
    activo?: boolean | null
  }

  export type departamentosUpdateInput = {
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type departamentosUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type departamentosCreateManyInput = {
    id?: number
    nombre?: string | null
    descripcion?: string | null
    activo?: boolean | null
  }

  export type departamentosUpdateManyMutationInput = {
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type departamentosUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type documentosCreateInput = {
    nombre?: string | null
    descripcion?: string | null
    mime?: string | null
    ruta?: string | null
    fecha_subida?: Date | string | null
    tipos_documentos?: tipos_documentosCreateNestedOneWithoutDocumentosInput
    usuarios?: usuariosCreateNestedOneWithoutDocumentosInput
  }

  export type documentosUncheckedCreateInput = {
    id?: number
    nombre?: string | null
    descripcion?: string | null
    mime?: string | null
    ruta?: string | null
    tipos_documentos_id?: number | null
    usuarios_id?: number | null
    fecha_subida?: Date | string | null
  }

  export type documentosUpdateInput = {
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    mime?: NullableStringFieldUpdateOperationsInput | string | null
    ruta?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_subida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipos_documentos?: tipos_documentosUpdateOneWithoutDocumentosNestedInput
    usuarios?: usuariosUpdateOneWithoutDocumentosNestedInput
  }

  export type documentosUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    mime?: NullableStringFieldUpdateOperationsInput | string | null
    ruta?: NullableStringFieldUpdateOperationsInput | string | null
    tipos_documentos_id?: NullableIntFieldUpdateOperationsInput | number | null
    usuarios_id?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_subida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type documentosCreateManyInput = {
    id?: number
    nombre?: string | null
    descripcion?: string | null
    mime?: string | null
    ruta?: string | null
    tipos_documentos_id?: number | null
    usuarios_id?: number | null
    fecha_subida?: Date | string | null
  }

  export type documentosUpdateManyMutationInput = {
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    mime?: NullableStringFieldUpdateOperationsInput | string | null
    ruta?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_subida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type documentosUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    mime?: NullableStringFieldUpdateOperationsInput | string | null
    ruta?: NullableStringFieldUpdateOperationsInput | string | null
    tipos_documentos_id?: NullableIntFieldUpdateOperationsInput | number | null
    usuarios_id?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_subida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type periodosCreateInput = {
    periodo?: string | null
    fecha_inicio?: Date | string | null
    fecha_final?: Date | string | null
    activo?: boolean | null
  }

  export type periodosUncheckedCreateInput = {
    id?: number
    periodo?: string | null
    fecha_inicio?: Date | string | null
    fecha_final?: Date | string | null
    activo?: boolean | null
  }

  export type periodosUpdateInput = {
    periodo?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_final?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activo?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type periodosUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    periodo?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_final?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activo?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type periodosCreateManyInput = {
    id?: number
    periodo?: string | null
    fecha_inicio?: Date | string | null
    fecha_final?: Date | string | null
    activo?: boolean | null
  }

  export type periodosUpdateManyMutationInput = {
    periodo?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_final?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activo?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type periodosUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    periodo?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_final?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activo?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type procesosCreateInput = {
    estatus: $Enums.procesos_estatus
    resultado?: $Enums.procesos_resultado | null
    fecha_inicio?: Date | string | null
    fecha_fin?: Date | string | null
    departamentos_id?: number | null
    periodos_id?: number | null
  }

  export type procesosUncheckedCreateInput = {
    id?: number
    estatus: $Enums.procesos_estatus
    resultado?: $Enums.procesos_resultado | null
    fecha_inicio?: Date | string | null
    fecha_fin?: Date | string | null
    departamentos_id?: number | null
    periodos_id?: number | null
  }

  export type procesosUpdateInput = {
    estatus?: Enumprocesos_estatusFieldUpdateOperationsInput | $Enums.procesos_estatus
    resultado?: NullableEnumprocesos_resultadoFieldUpdateOperationsInput | $Enums.procesos_resultado | null
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departamentos_id?: NullableIntFieldUpdateOperationsInput | number | null
    periodos_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type procesosUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    estatus?: Enumprocesos_estatusFieldUpdateOperationsInput | $Enums.procesos_estatus
    resultado?: NullableEnumprocesos_resultadoFieldUpdateOperationsInput | $Enums.procesos_resultado | null
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departamentos_id?: NullableIntFieldUpdateOperationsInput | number | null
    periodos_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type procesosCreateManyInput = {
    id?: number
    estatus: $Enums.procesos_estatus
    resultado?: $Enums.procesos_resultado | null
    fecha_inicio?: Date | string | null
    fecha_fin?: Date | string | null
    departamentos_id?: number | null
    periodos_id?: number | null
  }

  export type procesosUpdateManyMutationInput = {
    estatus?: Enumprocesos_estatusFieldUpdateOperationsInput | $Enums.procesos_estatus
    resultado?: NullableEnumprocesos_resultadoFieldUpdateOperationsInput | $Enums.procesos_resultado | null
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departamentos_id?: NullableIntFieldUpdateOperationsInput | number | null
    periodos_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type procesosUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    estatus?: Enumprocesos_estatusFieldUpdateOperationsInput | $Enums.procesos_estatus
    resultado?: NullableEnumprocesos_resultadoFieldUpdateOperationsInput | $Enums.procesos_resultado | null
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departamentos_id?: NullableIntFieldUpdateOperationsInput | number | null
    periodos_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type rolesCreateInput = {
    tipo: $Enums.roles_tipo
    descripcion?: string | null
    activo?: boolean | null
    fecha_creacion?: Date | string | null
    usuarios_has_roles?: usuarios_has_rolesCreateNestedManyWithoutRolesInput
  }

  export type rolesUncheckedCreateInput = {
    id?: number
    tipo: $Enums.roles_tipo
    descripcion?: string | null
    activo?: boolean | null
    fecha_creacion?: Date | string | null
    usuarios_has_roles?: usuarios_has_rolesUncheckedCreateNestedManyWithoutRolesInput
  }

  export type rolesUpdateInput = {
    tipo?: Enumroles_tipoFieldUpdateOperationsInput | $Enums.roles_tipo
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha_creacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usuarios_has_roles?: usuarios_has_rolesUpdateManyWithoutRolesNestedInput
  }

  export type rolesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipo?: Enumroles_tipoFieldUpdateOperationsInput | $Enums.roles_tipo
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha_creacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usuarios_has_roles?: usuarios_has_rolesUncheckedUpdateManyWithoutRolesNestedInput
  }

  export type rolesCreateManyInput = {
    id?: number
    tipo: $Enums.roles_tipo
    descripcion?: string | null
    activo?: boolean | null
    fecha_creacion?: Date | string | null
  }

  export type rolesUpdateManyMutationInput = {
    tipo?: Enumroles_tipoFieldUpdateOperationsInput | $Enums.roles_tipo
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha_creacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type rolesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipo?: Enumroles_tipoFieldUpdateOperationsInput | $Enums.roles_tipo
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha_creacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type tipos_documentosCreateInput = {
    tipo?: string | null
    documentos?: documentosCreateNestedManyWithoutTipos_documentosInput
  }

  export type tipos_documentosUncheckedCreateInput = {
    id?: number
    tipo?: string | null
    documentos?: documentosUncheckedCreateNestedManyWithoutTipos_documentosInput
  }

  export type tipos_documentosUpdateInput = {
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    documentos?: documentosUpdateManyWithoutTipos_documentosNestedInput
  }

  export type tipos_documentosUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    documentos?: documentosUncheckedUpdateManyWithoutTipos_documentosNestedInput
  }

  export type tipos_documentosCreateManyInput = {
    id?: number
    tipo?: string | null
  }

  export type tipos_documentosUpdateManyMutationInput = {
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tipos_documentosUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type usuariosCreateInput = {
    nombre?: string | null
    apellidos?: string | null
    email?: string | null
    password?: string | null
    departamentos_id?: number | null
    activo?: number | null
    documentos?: documentosCreateNestedManyWithoutUsuariosInput
    usuarios_has_roles?: usuarios_has_rolesCreateNestedManyWithoutUsuariosInput
  }

  export type usuariosUncheckedCreateInput = {
    id?: number
    nombre?: string | null
    apellidos?: string | null
    email?: string | null
    password?: string | null
    departamentos_id?: number | null
    activo?: number | null
    documentos?: documentosUncheckedCreateNestedManyWithoutUsuariosInput
    usuarios_has_roles?: usuarios_has_rolesUncheckedCreateNestedManyWithoutUsuariosInput
  }

  export type usuariosUpdateInput = {
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    apellidos?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    departamentos_id?: NullableIntFieldUpdateOperationsInput | number | null
    activo?: NullableIntFieldUpdateOperationsInput | number | null
    documentos?: documentosUpdateManyWithoutUsuariosNestedInput
    usuarios_has_roles?: usuarios_has_rolesUpdateManyWithoutUsuariosNestedInput
  }

  export type usuariosUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    apellidos?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    departamentos_id?: NullableIntFieldUpdateOperationsInput | number | null
    activo?: NullableIntFieldUpdateOperationsInput | number | null
    documentos?: documentosUncheckedUpdateManyWithoutUsuariosNestedInput
    usuarios_has_roles?: usuarios_has_rolesUncheckedUpdateManyWithoutUsuariosNestedInput
  }

  export type usuariosCreateManyInput = {
    id?: number
    nombre?: string | null
    apellidos?: string | null
    email?: string | null
    password?: string | null
    departamentos_id?: number | null
    activo?: number | null
  }

  export type usuariosUpdateManyMutationInput = {
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    apellidos?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    departamentos_id?: NullableIntFieldUpdateOperationsInput | number | null
    activo?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type usuariosUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    apellidos?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    departamentos_id?: NullableIntFieldUpdateOperationsInput | number | null
    activo?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type usuarios_has_rolesCreateInput = {
    usuarios: usuariosCreateNestedOneWithoutUsuarios_has_rolesInput
    roles: rolesCreateNestedOneWithoutUsuarios_has_rolesInput
  }

  export type usuarios_has_rolesUncheckedCreateInput = {
    usuarios_id: number
    roles_id: number
  }

  export type usuarios_has_rolesUpdateInput = {
    usuarios?: usuariosUpdateOneRequiredWithoutUsuarios_has_rolesNestedInput
    roles?: rolesUpdateOneRequiredWithoutUsuarios_has_rolesNestedInput
  }

  export type usuarios_has_rolesUncheckedUpdateInput = {
    usuarios_id?: IntFieldUpdateOperationsInput | number
    roles_id?: IntFieldUpdateOperationsInput | number
  }

  export type usuarios_has_rolesCreateManyInput = {
    usuarios_id: number
    roles_id: number
  }

  export type usuarios_has_rolesUpdateManyMutationInput = {

  }

  export type usuarios_has_rolesUncheckedUpdateManyInput = {
    usuarios_id?: IntFieldUpdateOperationsInput | number
    roles_id?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type bitacoraOrderByRelevanceInput = {
    fields: bitacoraOrderByRelevanceFieldEnum | bitacoraOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type bitacoraCountOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    rol?: SortOrder
    accion?: SortOrder
    ip?: SortOrder
    descripcion?: SortOrder
    fecha_inicio?: SortOrder
    fecha_act?: SortOrder
  }

  export type bitacoraAvgOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
  }

  export type bitacoraMaxOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    rol?: SortOrder
    accion?: SortOrder
    ip?: SortOrder
    descripcion?: SortOrder
    fecha_inicio?: SortOrder
    fecha_act?: SortOrder
  }

  export type bitacoraMinOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    rol?: SortOrder
    accion?: SortOrder
    ip?: SortOrder
    descripcion?: SortOrder
    fecha_inicio?: SortOrder
    fecha_act?: SortOrder
  }

  export type bitacoraSumOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type departamentosOrderByRelevanceInput = {
    fields: departamentosOrderByRelevanceFieldEnum | departamentosOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type departamentosCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    activo?: SortOrder
  }

  export type departamentosAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type departamentosMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    activo?: SortOrder
  }

  export type departamentosMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    activo?: SortOrder
  }

  export type departamentosSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type Tipos_documentosNullableScalarRelationFilter = {
    is?: tipos_documentosWhereInput | null
    isNot?: tipos_documentosWhereInput | null
  }

  export type UsuariosNullableScalarRelationFilter = {
    is?: usuariosWhereInput | null
    isNot?: usuariosWhereInput | null
  }

  export type documentosOrderByRelevanceInput = {
    fields: documentosOrderByRelevanceFieldEnum | documentosOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type documentosCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    mime?: SortOrder
    ruta?: SortOrder
    tipos_documentos_id?: SortOrder
    usuarios_id?: SortOrder
    fecha_subida?: SortOrder
  }

  export type documentosAvgOrderByAggregateInput = {
    id?: SortOrder
    tipos_documentos_id?: SortOrder
    usuarios_id?: SortOrder
  }

  export type documentosMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    mime?: SortOrder
    ruta?: SortOrder
    tipos_documentos_id?: SortOrder
    usuarios_id?: SortOrder
    fecha_subida?: SortOrder
  }

  export type documentosMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    mime?: SortOrder
    ruta?: SortOrder
    tipos_documentos_id?: SortOrder
    usuarios_id?: SortOrder
    fecha_subida?: SortOrder
  }

  export type documentosSumOrderByAggregateInput = {
    id?: SortOrder
    tipos_documentos_id?: SortOrder
    usuarios_id?: SortOrder
  }

  export type periodosOrderByRelevanceInput = {
    fields: periodosOrderByRelevanceFieldEnum | periodosOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type periodosCountOrderByAggregateInput = {
    id?: SortOrder
    periodo?: SortOrder
    fecha_inicio?: SortOrder
    fecha_final?: SortOrder
    activo?: SortOrder
  }

  export type periodosAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type periodosMaxOrderByAggregateInput = {
    id?: SortOrder
    periodo?: SortOrder
    fecha_inicio?: SortOrder
    fecha_final?: SortOrder
    activo?: SortOrder
  }

  export type periodosMinOrderByAggregateInput = {
    id?: SortOrder
    periodo?: SortOrder
    fecha_inicio?: SortOrder
    fecha_final?: SortOrder
    activo?: SortOrder
  }

  export type periodosSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Enumprocesos_estatusFilter<$PrismaModel = never> = {
    equals?: $Enums.procesos_estatus | Enumprocesos_estatusFieldRefInput<$PrismaModel>
    in?: $Enums.procesos_estatus[]
    notIn?: $Enums.procesos_estatus[]
    not?: NestedEnumprocesos_estatusFilter<$PrismaModel> | $Enums.procesos_estatus
  }

  export type Enumprocesos_resultadoNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.procesos_resultado | Enumprocesos_resultadoFieldRefInput<$PrismaModel> | null
    in?: $Enums.procesos_resultado[] | null
    notIn?: $Enums.procesos_resultado[] | null
    not?: NestedEnumprocesos_resultadoNullableFilter<$PrismaModel> | $Enums.procesos_resultado | null
  }

  export type procesosCountOrderByAggregateInput = {
    id?: SortOrder
    estatus?: SortOrder
    resultado?: SortOrder
    fecha_inicio?: SortOrder
    fecha_fin?: SortOrder
    departamentos_id?: SortOrder
    periodos_id?: SortOrder
  }

  export type procesosAvgOrderByAggregateInput = {
    id?: SortOrder
    departamentos_id?: SortOrder
    periodos_id?: SortOrder
  }

  export type procesosMaxOrderByAggregateInput = {
    id?: SortOrder
    estatus?: SortOrder
    resultado?: SortOrder
    fecha_inicio?: SortOrder
    fecha_fin?: SortOrder
    departamentos_id?: SortOrder
    periodos_id?: SortOrder
  }

  export type procesosMinOrderByAggregateInput = {
    id?: SortOrder
    estatus?: SortOrder
    resultado?: SortOrder
    fecha_inicio?: SortOrder
    fecha_fin?: SortOrder
    departamentos_id?: SortOrder
    periodos_id?: SortOrder
  }

  export type procesosSumOrderByAggregateInput = {
    id?: SortOrder
    departamentos_id?: SortOrder
    periodos_id?: SortOrder
  }

  export type Enumprocesos_estatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.procesos_estatus | Enumprocesos_estatusFieldRefInput<$PrismaModel>
    in?: $Enums.procesos_estatus[]
    notIn?: $Enums.procesos_estatus[]
    not?: NestedEnumprocesos_estatusWithAggregatesFilter<$PrismaModel> | $Enums.procesos_estatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumprocesos_estatusFilter<$PrismaModel>
    _max?: NestedEnumprocesos_estatusFilter<$PrismaModel>
  }

  export type Enumprocesos_resultadoNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.procesos_resultado | Enumprocesos_resultadoFieldRefInput<$PrismaModel> | null
    in?: $Enums.procesos_resultado[] | null
    notIn?: $Enums.procesos_resultado[] | null
    not?: NestedEnumprocesos_resultadoNullableWithAggregatesFilter<$PrismaModel> | $Enums.procesos_resultado | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumprocesos_resultadoNullableFilter<$PrismaModel>
    _max?: NestedEnumprocesos_resultadoNullableFilter<$PrismaModel>
  }

  export type Enumroles_tipoFilter<$PrismaModel = never> = {
    equals?: $Enums.roles_tipo | Enumroles_tipoFieldRefInput<$PrismaModel>
    in?: $Enums.roles_tipo[]
    notIn?: $Enums.roles_tipo[]
    not?: NestedEnumroles_tipoFilter<$PrismaModel> | $Enums.roles_tipo
  }

  export type Usuarios_has_rolesListRelationFilter = {
    every?: usuarios_has_rolesWhereInput
    some?: usuarios_has_rolesWhereInput
    none?: usuarios_has_rolesWhereInput
  }

  export type usuarios_has_rolesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type rolesOrderByRelevanceInput = {
    fields: rolesOrderByRelevanceFieldEnum | rolesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type rolesCountOrderByAggregateInput = {
    id?: SortOrder
    tipo?: SortOrder
    descripcion?: SortOrder
    activo?: SortOrder
    fecha_creacion?: SortOrder
  }

  export type rolesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type rolesMaxOrderByAggregateInput = {
    id?: SortOrder
    tipo?: SortOrder
    descripcion?: SortOrder
    activo?: SortOrder
    fecha_creacion?: SortOrder
  }

  export type rolesMinOrderByAggregateInput = {
    id?: SortOrder
    tipo?: SortOrder
    descripcion?: SortOrder
    activo?: SortOrder
    fecha_creacion?: SortOrder
  }

  export type rolesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Enumroles_tipoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.roles_tipo | Enumroles_tipoFieldRefInput<$PrismaModel>
    in?: $Enums.roles_tipo[]
    notIn?: $Enums.roles_tipo[]
    not?: NestedEnumroles_tipoWithAggregatesFilter<$PrismaModel> | $Enums.roles_tipo
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumroles_tipoFilter<$PrismaModel>
    _max?: NestedEnumroles_tipoFilter<$PrismaModel>
  }

  export type DocumentosListRelationFilter = {
    every?: documentosWhereInput
    some?: documentosWhereInput
    none?: documentosWhereInput
  }

  export type documentosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type tipos_documentosOrderByRelevanceInput = {
    fields: tipos_documentosOrderByRelevanceFieldEnum | tipos_documentosOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type tipos_documentosCountOrderByAggregateInput = {
    id?: SortOrder
    tipo?: SortOrder
  }

  export type tipos_documentosAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type tipos_documentosMaxOrderByAggregateInput = {
    id?: SortOrder
    tipo?: SortOrder
  }

  export type tipos_documentosMinOrderByAggregateInput = {
    id?: SortOrder
    tipo?: SortOrder
  }

  export type tipos_documentosSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type usuariosOrderByRelevanceInput = {
    fields: usuariosOrderByRelevanceFieldEnum | usuariosOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type usuariosCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellidos?: SortOrder
    email?: SortOrder
    password?: SortOrder
    departamentos_id?: SortOrder
    activo?: SortOrder
  }

  export type usuariosAvgOrderByAggregateInput = {
    id?: SortOrder
    departamentos_id?: SortOrder
    activo?: SortOrder
  }

  export type usuariosMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellidos?: SortOrder
    email?: SortOrder
    password?: SortOrder
    departamentos_id?: SortOrder
    activo?: SortOrder
  }

  export type usuariosMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellidos?: SortOrder
    email?: SortOrder
    password?: SortOrder
    departamentos_id?: SortOrder
    activo?: SortOrder
  }

  export type usuariosSumOrderByAggregateInput = {
    id?: SortOrder
    departamentos_id?: SortOrder
    activo?: SortOrder
  }

  export type UsuariosScalarRelationFilter = {
    is?: usuariosWhereInput
    isNot?: usuariosWhereInput
  }

  export type RolesScalarRelationFilter = {
    is?: rolesWhereInput
    isNot?: rolesWhereInput
  }

  export type usuarios_has_rolesUsuarios_idRoles_idCompoundUniqueInput = {
    usuarios_id: number
    roles_id: number
  }

  export type usuarios_has_rolesCountOrderByAggregateInput = {
    usuarios_id?: SortOrder
    roles_id?: SortOrder
  }

  export type usuarios_has_rolesAvgOrderByAggregateInput = {
    usuarios_id?: SortOrder
    roles_id?: SortOrder
  }

  export type usuarios_has_rolesMaxOrderByAggregateInput = {
    usuarios_id?: SortOrder
    roles_id?: SortOrder
  }

  export type usuarios_has_rolesMinOrderByAggregateInput = {
    usuarios_id?: SortOrder
    roles_id?: SortOrder
  }

  export type usuarios_has_rolesSumOrderByAggregateInput = {
    usuarios_id?: SortOrder
    roles_id?: SortOrder
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type tipos_documentosCreateNestedOneWithoutDocumentosInput = {
    create?: XOR<tipos_documentosCreateWithoutDocumentosInput, tipos_documentosUncheckedCreateWithoutDocumentosInput>
    connectOrCreate?: tipos_documentosCreateOrConnectWithoutDocumentosInput
    connect?: tipos_documentosWhereUniqueInput
  }

  export type usuariosCreateNestedOneWithoutDocumentosInput = {
    create?: XOR<usuariosCreateWithoutDocumentosInput, usuariosUncheckedCreateWithoutDocumentosInput>
    connectOrCreate?: usuariosCreateOrConnectWithoutDocumentosInput
    connect?: usuariosWhereUniqueInput
  }

  export type tipos_documentosUpdateOneWithoutDocumentosNestedInput = {
    create?: XOR<tipos_documentosCreateWithoutDocumentosInput, tipos_documentosUncheckedCreateWithoutDocumentosInput>
    connectOrCreate?: tipos_documentosCreateOrConnectWithoutDocumentosInput
    upsert?: tipos_documentosUpsertWithoutDocumentosInput
    disconnect?: tipos_documentosWhereInput | boolean
    delete?: tipos_documentosWhereInput | boolean
    connect?: tipos_documentosWhereUniqueInput
    update?: XOR<XOR<tipos_documentosUpdateToOneWithWhereWithoutDocumentosInput, tipos_documentosUpdateWithoutDocumentosInput>, tipos_documentosUncheckedUpdateWithoutDocumentosInput>
  }

  export type usuariosUpdateOneWithoutDocumentosNestedInput = {
    create?: XOR<usuariosCreateWithoutDocumentosInput, usuariosUncheckedCreateWithoutDocumentosInput>
    connectOrCreate?: usuariosCreateOrConnectWithoutDocumentosInput
    upsert?: usuariosUpsertWithoutDocumentosInput
    disconnect?: usuariosWhereInput | boolean
    delete?: usuariosWhereInput | boolean
    connect?: usuariosWhereUniqueInput
    update?: XOR<XOR<usuariosUpdateToOneWithWhereWithoutDocumentosInput, usuariosUpdateWithoutDocumentosInput>, usuariosUncheckedUpdateWithoutDocumentosInput>
  }

  export type Enumprocesos_estatusFieldUpdateOperationsInput = {
    set?: $Enums.procesos_estatus
  }

  export type NullableEnumprocesos_resultadoFieldUpdateOperationsInput = {
    set?: $Enums.procesos_resultado | null
  }

  export type usuarios_has_rolesCreateNestedManyWithoutRolesInput = {
    create?: XOR<usuarios_has_rolesCreateWithoutRolesInput, usuarios_has_rolesUncheckedCreateWithoutRolesInput> | usuarios_has_rolesCreateWithoutRolesInput[] | usuarios_has_rolesUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: usuarios_has_rolesCreateOrConnectWithoutRolesInput | usuarios_has_rolesCreateOrConnectWithoutRolesInput[]
    createMany?: usuarios_has_rolesCreateManyRolesInputEnvelope
    connect?: usuarios_has_rolesWhereUniqueInput | usuarios_has_rolesWhereUniqueInput[]
  }

  export type usuarios_has_rolesUncheckedCreateNestedManyWithoutRolesInput = {
    create?: XOR<usuarios_has_rolesCreateWithoutRolesInput, usuarios_has_rolesUncheckedCreateWithoutRolesInput> | usuarios_has_rolesCreateWithoutRolesInput[] | usuarios_has_rolesUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: usuarios_has_rolesCreateOrConnectWithoutRolesInput | usuarios_has_rolesCreateOrConnectWithoutRolesInput[]
    createMany?: usuarios_has_rolesCreateManyRolesInputEnvelope
    connect?: usuarios_has_rolesWhereUniqueInput | usuarios_has_rolesWhereUniqueInput[]
  }

  export type Enumroles_tipoFieldUpdateOperationsInput = {
    set?: $Enums.roles_tipo
  }

  export type usuarios_has_rolesUpdateManyWithoutRolesNestedInput = {
    create?: XOR<usuarios_has_rolesCreateWithoutRolesInput, usuarios_has_rolesUncheckedCreateWithoutRolesInput> | usuarios_has_rolesCreateWithoutRolesInput[] | usuarios_has_rolesUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: usuarios_has_rolesCreateOrConnectWithoutRolesInput | usuarios_has_rolesCreateOrConnectWithoutRolesInput[]
    upsert?: usuarios_has_rolesUpsertWithWhereUniqueWithoutRolesInput | usuarios_has_rolesUpsertWithWhereUniqueWithoutRolesInput[]
    createMany?: usuarios_has_rolesCreateManyRolesInputEnvelope
    set?: usuarios_has_rolesWhereUniqueInput | usuarios_has_rolesWhereUniqueInput[]
    disconnect?: usuarios_has_rolesWhereUniqueInput | usuarios_has_rolesWhereUniqueInput[]
    delete?: usuarios_has_rolesWhereUniqueInput | usuarios_has_rolesWhereUniqueInput[]
    connect?: usuarios_has_rolesWhereUniqueInput | usuarios_has_rolesWhereUniqueInput[]
    update?: usuarios_has_rolesUpdateWithWhereUniqueWithoutRolesInput | usuarios_has_rolesUpdateWithWhereUniqueWithoutRolesInput[]
    updateMany?: usuarios_has_rolesUpdateManyWithWhereWithoutRolesInput | usuarios_has_rolesUpdateManyWithWhereWithoutRolesInput[]
    deleteMany?: usuarios_has_rolesScalarWhereInput | usuarios_has_rolesScalarWhereInput[]
  }

  export type usuarios_has_rolesUncheckedUpdateManyWithoutRolesNestedInput = {
    create?: XOR<usuarios_has_rolesCreateWithoutRolesInput, usuarios_has_rolesUncheckedCreateWithoutRolesInput> | usuarios_has_rolesCreateWithoutRolesInput[] | usuarios_has_rolesUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: usuarios_has_rolesCreateOrConnectWithoutRolesInput | usuarios_has_rolesCreateOrConnectWithoutRolesInput[]
    upsert?: usuarios_has_rolesUpsertWithWhereUniqueWithoutRolesInput | usuarios_has_rolesUpsertWithWhereUniqueWithoutRolesInput[]
    createMany?: usuarios_has_rolesCreateManyRolesInputEnvelope
    set?: usuarios_has_rolesWhereUniqueInput | usuarios_has_rolesWhereUniqueInput[]
    disconnect?: usuarios_has_rolesWhereUniqueInput | usuarios_has_rolesWhereUniqueInput[]
    delete?: usuarios_has_rolesWhereUniqueInput | usuarios_has_rolesWhereUniqueInput[]
    connect?: usuarios_has_rolesWhereUniqueInput | usuarios_has_rolesWhereUniqueInput[]
    update?: usuarios_has_rolesUpdateWithWhereUniqueWithoutRolesInput | usuarios_has_rolesUpdateWithWhereUniqueWithoutRolesInput[]
    updateMany?: usuarios_has_rolesUpdateManyWithWhereWithoutRolesInput | usuarios_has_rolesUpdateManyWithWhereWithoutRolesInput[]
    deleteMany?: usuarios_has_rolesScalarWhereInput | usuarios_has_rolesScalarWhereInput[]
  }

  export type documentosCreateNestedManyWithoutTipos_documentosInput = {
    create?: XOR<documentosCreateWithoutTipos_documentosInput, documentosUncheckedCreateWithoutTipos_documentosInput> | documentosCreateWithoutTipos_documentosInput[] | documentosUncheckedCreateWithoutTipos_documentosInput[]
    connectOrCreate?: documentosCreateOrConnectWithoutTipos_documentosInput | documentosCreateOrConnectWithoutTipos_documentosInput[]
    createMany?: documentosCreateManyTipos_documentosInputEnvelope
    connect?: documentosWhereUniqueInput | documentosWhereUniqueInput[]
  }

  export type documentosUncheckedCreateNestedManyWithoutTipos_documentosInput = {
    create?: XOR<documentosCreateWithoutTipos_documentosInput, documentosUncheckedCreateWithoutTipos_documentosInput> | documentosCreateWithoutTipos_documentosInput[] | documentosUncheckedCreateWithoutTipos_documentosInput[]
    connectOrCreate?: documentosCreateOrConnectWithoutTipos_documentosInput | documentosCreateOrConnectWithoutTipos_documentosInput[]
    createMany?: documentosCreateManyTipos_documentosInputEnvelope
    connect?: documentosWhereUniqueInput | documentosWhereUniqueInput[]
  }

  export type documentosUpdateManyWithoutTipos_documentosNestedInput = {
    create?: XOR<documentosCreateWithoutTipos_documentosInput, documentosUncheckedCreateWithoutTipos_documentosInput> | documentosCreateWithoutTipos_documentosInput[] | documentosUncheckedCreateWithoutTipos_documentosInput[]
    connectOrCreate?: documentosCreateOrConnectWithoutTipos_documentosInput | documentosCreateOrConnectWithoutTipos_documentosInput[]
    upsert?: documentosUpsertWithWhereUniqueWithoutTipos_documentosInput | documentosUpsertWithWhereUniqueWithoutTipos_documentosInput[]
    createMany?: documentosCreateManyTipos_documentosInputEnvelope
    set?: documentosWhereUniqueInput | documentosWhereUniqueInput[]
    disconnect?: documentosWhereUniqueInput | documentosWhereUniqueInput[]
    delete?: documentosWhereUniqueInput | documentosWhereUniqueInput[]
    connect?: documentosWhereUniqueInput | documentosWhereUniqueInput[]
    update?: documentosUpdateWithWhereUniqueWithoutTipos_documentosInput | documentosUpdateWithWhereUniqueWithoutTipos_documentosInput[]
    updateMany?: documentosUpdateManyWithWhereWithoutTipos_documentosInput | documentosUpdateManyWithWhereWithoutTipos_documentosInput[]
    deleteMany?: documentosScalarWhereInput | documentosScalarWhereInput[]
  }

  export type documentosUncheckedUpdateManyWithoutTipos_documentosNestedInput = {
    create?: XOR<documentosCreateWithoutTipos_documentosInput, documentosUncheckedCreateWithoutTipos_documentosInput> | documentosCreateWithoutTipos_documentosInput[] | documentosUncheckedCreateWithoutTipos_documentosInput[]
    connectOrCreate?: documentosCreateOrConnectWithoutTipos_documentosInput | documentosCreateOrConnectWithoutTipos_documentosInput[]
    upsert?: documentosUpsertWithWhereUniqueWithoutTipos_documentosInput | documentosUpsertWithWhereUniqueWithoutTipos_documentosInput[]
    createMany?: documentosCreateManyTipos_documentosInputEnvelope
    set?: documentosWhereUniqueInput | documentosWhereUniqueInput[]
    disconnect?: documentosWhereUniqueInput | documentosWhereUniqueInput[]
    delete?: documentosWhereUniqueInput | documentosWhereUniqueInput[]
    connect?: documentosWhereUniqueInput | documentosWhereUniqueInput[]
    update?: documentosUpdateWithWhereUniqueWithoutTipos_documentosInput | documentosUpdateWithWhereUniqueWithoutTipos_documentosInput[]
    updateMany?: documentosUpdateManyWithWhereWithoutTipos_documentosInput | documentosUpdateManyWithWhereWithoutTipos_documentosInput[]
    deleteMany?: documentosScalarWhereInput | documentosScalarWhereInput[]
  }

  export type documentosCreateNestedManyWithoutUsuariosInput = {
    create?: XOR<documentosCreateWithoutUsuariosInput, documentosUncheckedCreateWithoutUsuariosInput> | documentosCreateWithoutUsuariosInput[] | documentosUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: documentosCreateOrConnectWithoutUsuariosInput | documentosCreateOrConnectWithoutUsuariosInput[]
    createMany?: documentosCreateManyUsuariosInputEnvelope
    connect?: documentosWhereUniqueInput | documentosWhereUniqueInput[]
  }

  export type usuarios_has_rolesCreateNestedManyWithoutUsuariosInput = {
    create?: XOR<usuarios_has_rolesCreateWithoutUsuariosInput, usuarios_has_rolesUncheckedCreateWithoutUsuariosInput> | usuarios_has_rolesCreateWithoutUsuariosInput[] | usuarios_has_rolesUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: usuarios_has_rolesCreateOrConnectWithoutUsuariosInput | usuarios_has_rolesCreateOrConnectWithoutUsuariosInput[]
    createMany?: usuarios_has_rolesCreateManyUsuariosInputEnvelope
    connect?: usuarios_has_rolesWhereUniqueInput | usuarios_has_rolesWhereUniqueInput[]
  }

  export type documentosUncheckedCreateNestedManyWithoutUsuariosInput = {
    create?: XOR<documentosCreateWithoutUsuariosInput, documentosUncheckedCreateWithoutUsuariosInput> | documentosCreateWithoutUsuariosInput[] | documentosUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: documentosCreateOrConnectWithoutUsuariosInput | documentosCreateOrConnectWithoutUsuariosInput[]
    createMany?: documentosCreateManyUsuariosInputEnvelope
    connect?: documentosWhereUniqueInput | documentosWhereUniqueInput[]
  }

  export type usuarios_has_rolesUncheckedCreateNestedManyWithoutUsuariosInput = {
    create?: XOR<usuarios_has_rolesCreateWithoutUsuariosInput, usuarios_has_rolesUncheckedCreateWithoutUsuariosInput> | usuarios_has_rolesCreateWithoutUsuariosInput[] | usuarios_has_rolesUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: usuarios_has_rolesCreateOrConnectWithoutUsuariosInput | usuarios_has_rolesCreateOrConnectWithoutUsuariosInput[]
    createMany?: usuarios_has_rolesCreateManyUsuariosInputEnvelope
    connect?: usuarios_has_rolesWhereUniqueInput | usuarios_has_rolesWhereUniqueInput[]
  }

  export type documentosUpdateManyWithoutUsuariosNestedInput = {
    create?: XOR<documentosCreateWithoutUsuariosInput, documentosUncheckedCreateWithoutUsuariosInput> | documentosCreateWithoutUsuariosInput[] | documentosUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: documentosCreateOrConnectWithoutUsuariosInput | documentosCreateOrConnectWithoutUsuariosInput[]
    upsert?: documentosUpsertWithWhereUniqueWithoutUsuariosInput | documentosUpsertWithWhereUniqueWithoutUsuariosInput[]
    createMany?: documentosCreateManyUsuariosInputEnvelope
    set?: documentosWhereUniqueInput | documentosWhereUniqueInput[]
    disconnect?: documentosWhereUniqueInput | documentosWhereUniqueInput[]
    delete?: documentosWhereUniqueInput | documentosWhereUniqueInput[]
    connect?: documentosWhereUniqueInput | documentosWhereUniqueInput[]
    update?: documentosUpdateWithWhereUniqueWithoutUsuariosInput | documentosUpdateWithWhereUniqueWithoutUsuariosInput[]
    updateMany?: documentosUpdateManyWithWhereWithoutUsuariosInput | documentosUpdateManyWithWhereWithoutUsuariosInput[]
    deleteMany?: documentosScalarWhereInput | documentosScalarWhereInput[]
  }

  export type usuarios_has_rolesUpdateManyWithoutUsuariosNestedInput = {
    create?: XOR<usuarios_has_rolesCreateWithoutUsuariosInput, usuarios_has_rolesUncheckedCreateWithoutUsuariosInput> | usuarios_has_rolesCreateWithoutUsuariosInput[] | usuarios_has_rolesUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: usuarios_has_rolesCreateOrConnectWithoutUsuariosInput | usuarios_has_rolesCreateOrConnectWithoutUsuariosInput[]
    upsert?: usuarios_has_rolesUpsertWithWhereUniqueWithoutUsuariosInput | usuarios_has_rolesUpsertWithWhereUniqueWithoutUsuariosInput[]
    createMany?: usuarios_has_rolesCreateManyUsuariosInputEnvelope
    set?: usuarios_has_rolesWhereUniqueInput | usuarios_has_rolesWhereUniqueInput[]
    disconnect?: usuarios_has_rolesWhereUniqueInput | usuarios_has_rolesWhereUniqueInput[]
    delete?: usuarios_has_rolesWhereUniqueInput | usuarios_has_rolesWhereUniqueInput[]
    connect?: usuarios_has_rolesWhereUniqueInput | usuarios_has_rolesWhereUniqueInput[]
    update?: usuarios_has_rolesUpdateWithWhereUniqueWithoutUsuariosInput | usuarios_has_rolesUpdateWithWhereUniqueWithoutUsuariosInput[]
    updateMany?: usuarios_has_rolesUpdateManyWithWhereWithoutUsuariosInput | usuarios_has_rolesUpdateManyWithWhereWithoutUsuariosInput[]
    deleteMany?: usuarios_has_rolesScalarWhereInput | usuarios_has_rolesScalarWhereInput[]
  }

  export type documentosUncheckedUpdateManyWithoutUsuariosNestedInput = {
    create?: XOR<documentosCreateWithoutUsuariosInput, documentosUncheckedCreateWithoutUsuariosInput> | documentosCreateWithoutUsuariosInput[] | documentosUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: documentosCreateOrConnectWithoutUsuariosInput | documentosCreateOrConnectWithoutUsuariosInput[]
    upsert?: documentosUpsertWithWhereUniqueWithoutUsuariosInput | documentosUpsertWithWhereUniqueWithoutUsuariosInput[]
    createMany?: documentosCreateManyUsuariosInputEnvelope
    set?: documentosWhereUniqueInput | documentosWhereUniqueInput[]
    disconnect?: documentosWhereUniqueInput | documentosWhereUniqueInput[]
    delete?: documentosWhereUniqueInput | documentosWhereUniqueInput[]
    connect?: documentosWhereUniqueInput | documentosWhereUniqueInput[]
    update?: documentosUpdateWithWhereUniqueWithoutUsuariosInput | documentosUpdateWithWhereUniqueWithoutUsuariosInput[]
    updateMany?: documentosUpdateManyWithWhereWithoutUsuariosInput | documentosUpdateManyWithWhereWithoutUsuariosInput[]
    deleteMany?: documentosScalarWhereInput | documentosScalarWhereInput[]
  }

  export type usuarios_has_rolesUncheckedUpdateManyWithoutUsuariosNestedInput = {
    create?: XOR<usuarios_has_rolesCreateWithoutUsuariosInput, usuarios_has_rolesUncheckedCreateWithoutUsuariosInput> | usuarios_has_rolesCreateWithoutUsuariosInput[] | usuarios_has_rolesUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: usuarios_has_rolesCreateOrConnectWithoutUsuariosInput | usuarios_has_rolesCreateOrConnectWithoutUsuariosInput[]
    upsert?: usuarios_has_rolesUpsertWithWhereUniqueWithoutUsuariosInput | usuarios_has_rolesUpsertWithWhereUniqueWithoutUsuariosInput[]
    createMany?: usuarios_has_rolesCreateManyUsuariosInputEnvelope
    set?: usuarios_has_rolesWhereUniqueInput | usuarios_has_rolesWhereUniqueInput[]
    disconnect?: usuarios_has_rolesWhereUniqueInput | usuarios_has_rolesWhereUniqueInput[]
    delete?: usuarios_has_rolesWhereUniqueInput | usuarios_has_rolesWhereUniqueInput[]
    connect?: usuarios_has_rolesWhereUniqueInput | usuarios_has_rolesWhereUniqueInput[]
    update?: usuarios_has_rolesUpdateWithWhereUniqueWithoutUsuariosInput | usuarios_has_rolesUpdateWithWhereUniqueWithoutUsuariosInput[]
    updateMany?: usuarios_has_rolesUpdateManyWithWhereWithoutUsuariosInput | usuarios_has_rolesUpdateManyWithWhereWithoutUsuariosInput[]
    deleteMany?: usuarios_has_rolesScalarWhereInput | usuarios_has_rolesScalarWhereInput[]
  }

  export type usuariosCreateNestedOneWithoutUsuarios_has_rolesInput = {
    create?: XOR<usuariosCreateWithoutUsuarios_has_rolesInput, usuariosUncheckedCreateWithoutUsuarios_has_rolesInput>
    connectOrCreate?: usuariosCreateOrConnectWithoutUsuarios_has_rolesInput
    connect?: usuariosWhereUniqueInput
  }

  export type rolesCreateNestedOneWithoutUsuarios_has_rolesInput = {
    create?: XOR<rolesCreateWithoutUsuarios_has_rolesInput, rolesUncheckedCreateWithoutUsuarios_has_rolesInput>
    connectOrCreate?: rolesCreateOrConnectWithoutUsuarios_has_rolesInput
    connect?: rolesWhereUniqueInput
  }

  export type usuariosUpdateOneRequiredWithoutUsuarios_has_rolesNestedInput = {
    create?: XOR<usuariosCreateWithoutUsuarios_has_rolesInput, usuariosUncheckedCreateWithoutUsuarios_has_rolesInput>
    connectOrCreate?: usuariosCreateOrConnectWithoutUsuarios_has_rolesInput
    upsert?: usuariosUpsertWithoutUsuarios_has_rolesInput
    connect?: usuariosWhereUniqueInput
    update?: XOR<XOR<usuariosUpdateToOneWithWhereWithoutUsuarios_has_rolesInput, usuariosUpdateWithoutUsuarios_has_rolesInput>, usuariosUncheckedUpdateWithoutUsuarios_has_rolesInput>
  }

  export type rolesUpdateOneRequiredWithoutUsuarios_has_rolesNestedInput = {
    create?: XOR<rolesCreateWithoutUsuarios_has_rolesInput, rolesUncheckedCreateWithoutUsuarios_has_rolesInput>
    connectOrCreate?: rolesCreateOrConnectWithoutUsuarios_has_rolesInput
    upsert?: rolesUpsertWithoutUsuarios_has_rolesInput
    connect?: rolesWhereUniqueInput
    update?: XOR<XOR<rolesUpdateToOneWithWhereWithoutUsuarios_has_rolesInput, rolesUpdateWithoutUsuarios_has_rolesInput>, rolesUncheckedUpdateWithoutUsuarios_has_rolesInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedEnumprocesos_estatusFilter<$PrismaModel = never> = {
    equals?: $Enums.procesos_estatus | Enumprocesos_estatusFieldRefInput<$PrismaModel>
    in?: $Enums.procesos_estatus[]
    notIn?: $Enums.procesos_estatus[]
    not?: NestedEnumprocesos_estatusFilter<$PrismaModel> | $Enums.procesos_estatus
  }

  export type NestedEnumprocesos_resultadoNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.procesos_resultado | Enumprocesos_resultadoFieldRefInput<$PrismaModel> | null
    in?: $Enums.procesos_resultado[] | null
    notIn?: $Enums.procesos_resultado[] | null
    not?: NestedEnumprocesos_resultadoNullableFilter<$PrismaModel> | $Enums.procesos_resultado | null
  }

  export type NestedEnumprocesos_estatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.procesos_estatus | Enumprocesos_estatusFieldRefInput<$PrismaModel>
    in?: $Enums.procesos_estatus[]
    notIn?: $Enums.procesos_estatus[]
    not?: NestedEnumprocesos_estatusWithAggregatesFilter<$PrismaModel> | $Enums.procesos_estatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumprocesos_estatusFilter<$PrismaModel>
    _max?: NestedEnumprocesos_estatusFilter<$PrismaModel>
  }

  export type NestedEnumprocesos_resultadoNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.procesos_resultado | Enumprocesos_resultadoFieldRefInput<$PrismaModel> | null
    in?: $Enums.procesos_resultado[] | null
    notIn?: $Enums.procesos_resultado[] | null
    not?: NestedEnumprocesos_resultadoNullableWithAggregatesFilter<$PrismaModel> | $Enums.procesos_resultado | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumprocesos_resultadoNullableFilter<$PrismaModel>
    _max?: NestedEnumprocesos_resultadoNullableFilter<$PrismaModel>
  }

  export type NestedEnumroles_tipoFilter<$PrismaModel = never> = {
    equals?: $Enums.roles_tipo | Enumroles_tipoFieldRefInput<$PrismaModel>
    in?: $Enums.roles_tipo[]
    notIn?: $Enums.roles_tipo[]
    not?: NestedEnumroles_tipoFilter<$PrismaModel> | $Enums.roles_tipo
  }

  export type NestedEnumroles_tipoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.roles_tipo | Enumroles_tipoFieldRefInput<$PrismaModel>
    in?: $Enums.roles_tipo[]
    notIn?: $Enums.roles_tipo[]
    not?: NestedEnumroles_tipoWithAggregatesFilter<$PrismaModel> | $Enums.roles_tipo
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumroles_tipoFilter<$PrismaModel>
    _max?: NestedEnumroles_tipoFilter<$PrismaModel>
  }

  export type tipos_documentosCreateWithoutDocumentosInput = {
    tipo?: string | null
  }

  export type tipos_documentosUncheckedCreateWithoutDocumentosInput = {
    id?: number
    tipo?: string | null
  }

  export type tipos_documentosCreateOrConnectWithoutDocumentosInput = {
    where: tipos_documentosWhereUniqueInput
    create: XOR<tipos_documentosCreateWithoutDocumentosInput, tipos_documentosUncheckedCreateWithoutDocumentosInput>
  }

  export type usuariosCreateWithoutDocumentosInput = {
    nombre?: string | null
    apellidos?: string | null
    email?: string | null
    password?: string | null
    departamentos_id?: number | null
    activo?: number | null
    usuarios_has_roles?: usuarios_has_rolesCreateNestedManyWithoutUsuariosInput
  }

  export type usuariosUncheckedCreateWithoutDocumentosInput = {
    id?: number
    nombre?: string | null
    apellidos?: string | null
    email?: string | null
    password?: string | null
    departamentos_id?: number | null
    activo?: number | null
    usuarios_has_roles?: usuarios_has_rolesUncheckedCreateNestedManyWithoutUsuariosInput
  }

  export type usuariosCreateOrConnectWithoutDocumentosInput = {
    where: usuariosWhereUniqueInput
    create: XOR<usuariosCreateWithoutDocumentosInput, usuariosUncheckedCreateWithoutDocumentosInput>
  }

  export type tipos_documentosUpsertWithoutDocumentosInput = {
    update: XOR<tipos_documentosUpdateWithoutDocumentosInput, tipos_documentosUncheckedUpdateWithoutDocumentosInput>
    create: XOR<tipos_documentosCreateWithoutDocumentosInput, tipos_documentosUncheckedCreateWithoutDocumentosInput>
    where?: tipos_documentosWhereInput
  }

  export type tipos_documentosUpdateToOneWithWhereWithoutDocumentosInput = {
    where?: tipos_documentosWhereInput
    data: XOR<tipos_documentosUpdateWithoutDocumentosInput, tipos_documentosUncheckedUpdateWithoutDocumentosInput>
  }

  export type tipos_documentosUpdateWithoutDocumentosInput = {
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tipos_documentosUncheckedUpdateWithoutDocumentosInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type usuariosUpsertWithoutDocumentosInput = {
    update: XOR<usuariosUpdateWithoutDocumentosInput, usuariosUncheckedUpdateWithoutDocumentosInput>
    create: XOR<usuariosCreateWithoutDocumentosInput, usuariosUncheckedCreateWithoutDocumentosInput>
    where?: usuariosWhereInput
  }

  export type usuariosUpdateToOneWithWhereWithoutDocumentosInput = {
    where?: usuariosWhereInput
    data: XOR<usuariosUpdateWithoutDocumentosInput, usuariosUncheckedUpdateWithoutDocumentosInput>
  }

  export type usuariosUpdateWithoutDocumentosInput = {
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    apellidos?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    departamentos_id?: NullableIntFieldUpdateOperationsInput | number | null
    activo?: NullableIntFieldUpdateOperationsInput | number | null
    usuarios_has_roles?: usuarios_has_rolesUpdateManyWithoutUsuariosNestedInput
  }

  export type usuariosUncheckedUpdateWithoutDocumentosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    apellidos?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    departamentos_id?: NullableIntFieldUpdateOperationsInput | number | null
    activo?: NullableIntFieldUpdateOperationsInput | number | null
    usuarios_has_roles?: usuarios_has_rolesUncheckedUpdateManyWithoutUsuariosNestedInput
  }

  export type usuarios_has_rolesCreateWithoutRolesInput = {
    usuarios: usuariosCreateNestedOneWithoutUsuarios_has_rolesInput
  }

  export type usuarios_has_rolesUncheckedCreateWithoutRolesInput = {
    usuarios_id: number
  }

  export type usuarios_has_rolesCreateOrConnectWithoutRolesInput = {
    where: usuarios_has_rolesWhereUniqueInput
    create: XOR<usuarios_has_rolesCreateWithoutRolesInput, usuarios_has_rolesUncheckedCreateWithoutRolesInput>
  }

  export type usuarios_has_rolesCreateManyRolesInputEnvelope = {
    data: usuarios_has_rolesCreateManyRolesInput | usuarios_has_rolesCreateManyRolesInput[]
    skipDuplicates?: boolean
  }

  export type usuarios_has_rolesUpsertWithWhereUniqueWithoutRolesInput = {
    where: usuarios_has_rolesWhereUniqueInput
    update: XOR<usuarios_has_rolesUpdateWithoutRolesInput, usuarios_has_rolesUncheckedUpdateWithoutRolesInput>
    create: XOR<usuarios_has_rolesCreateWithoutRolesInput, usuarios_has_rolesUncheckedCreateWithoutRolesInput>
  }

  export type usuarios_has_rolesUpdateWithWhereUniqueWithoutRolesInput = {
    where: usuarios_has_rolesWhereUniqueInput
    data: XOR<usuarios_has_rolesUpdateWithoutRolesInput, usuarios_has_rolesUncheckedUpdateWithoutRolesInput>
  }

  export type usuarios_has_rolesUpdateManyWithWhereWithoutRolesInput = {
    where: usuarios_has_rolesScalarWhereInput
    data: XOR<usuarios_has_rolesUpdateManyMutationInput, usuarios_has_rolesUncheckedUpdateManyWithoutRolesInput>
  }

  export type usuarios_has_rolesScalarWhereInput = {
    AND?: usuarios_has_rolesScalarWhereInput | usuarios_has_rolesScalarWhereInput[]
    OR?: usuarios_has_rolesScalarWhereInput[]
    NOT?: usuarios_has_rolesScalarWhereInput | usuarios_has_rolesScalarWhereInput[]
    usuarios_id?: IntFilter<"usuarios_has_roles"> | number
    roles_id?: IntFilter<"usuarios_has_roles"> | number
  }

  export type documentosCreateWithoutTipos_documentosInput = {
    nombre?: string | null
    descripcion?: string | null
    mime?: string | null
    ruta?: string | null
    fecha_subida?: Date | string | null
    usuarios?: usuariosCreateNestedOneWithoutDocumentosInput
  }

  export type documentosUncheckedCreateWithoutTipos_documentosInput = {
    id?: number
    nombre?: string | null
    descripcion?: string | null
    mime?: string | null
    ruta?: string | null
    usuarios_id?: number | null
    fecha_subida?: Date | string | null
  }

  export type documentosCreateOrConnectWithoutTipos_documentosInput = {
    where: documentosWhereUniqueInput
    create: XOR<documentosCreateWithoutTipos_documentosInput, documentosUncheckedCreateWithoutTipos_documentosInput>
  }

  export type documentosCreateManyTipos_documentosInputEnvelope = {
    data: documentosCreateManyTipos_documentosInput | documentosCreateManyTipos_documentosInput[]
    skipDuplicates?: boolean
  }

  export type documentosUpsertWithWhereUniqueWithoutTipos_documentosInput = {
    where: documentosWhereUniqueInput
    update: XOR<documentosUpdateWithoutTipos_documentosInput, documentosUncheckedUpdateWithoutTipos_documentosInput>
    create: XOR<documentosCreateWithoutTipos_documentosInput, documentosUncheckedCreateWithoutTipos_documentosInput>
  }

  export type documentosUpdateWithWhereUniqueWithoutTipos_documentosInput = {
    where: documentosWhereUniqueInput
    data: XOR<documentosUpdateWithoutTipos_documentosInput, documentosUncheckedUpdateWithoutTipos_documentosInput>
  }

  export type documentosUpdateManyWithWhereWithoutTipos_documentosInput = {
    where: documentosScalarWhereInput
    data: XOR<documentosUpdateManyMutationInput, documentosUncheckedUpdateManyWithoutTipos_documentosInput>
  }

  export type documentosScalarWhereInput = {
    AND?: documentosScalarWhereInput | documentosScalarWhereInput[]
    OR?: documentosScalarWhereInput[]
    NOT?: documentosScalarWhereInput | documentosScalarWhereInput[]
    id?: IntFilter<"documentos"> | number
    nombre?: StringNullableFilter<"documentos"> | string | null
    descripcion?: StringNullableFilter<"documentos"> | string | null
    mime?: StringNullableFilter<"documentos"> | string | null
    ruta?: StringNullableFilter<"documentos"> | string | null
    tipos_documentos_id?: IntNullableFilter<"documentos"> | number | null
    usuarios_id?: IntNullableFilter<"documentos"> | number | null
    fecha_subida?: DateTimeNullableFilter<"documentos"> | Date | string | null
  }

  export type documentosCreateWithoutUsuariosInput = {
    nombre?: string | null
    descripcion?: string | null
    mime?: string | null
    ruta?: string | null
    fecha_subida?: Date | string | null
    tipos_documentos?: tipos_documentosCreateNestedOneWithoutDocumentosInput
  }

  export type documentosUncheckedCreateWithoutUsuariosInput = {
    id?: number
    nombre?: string | null
    descripcion?: string | null
    mime?: string | null
    ruta?: string | null
    tipos_documentos_id?: number | null
    fecha_subida?: Date | string | null
  }

  export type documentosCreateOrConnectWithoutUsuariosInput = {
    where: documentosWhereUniqueInput
    create: XOR<documentosCreateWithoutUsuariosInput, documentosUncheckedCreateWithoutUsuariosInput>
  }

  export type documentosCreateManyUsuariosInputEnvelope = {
    data: documentosCreateManyUsuariosInput | documentosCreateManyUsuariosInput[]
    skipDuplicates?: boolean
  }

  export type usuarios_has_rolesCreateWithoutUsuariosInput = {
    roles: rolesCreateNestedOneWithoutUsuarios_has_rolesInput
  }

  export type usuarios_has_rolesUncheckedCreateWithoutUsuariosInput = {
    roles_id: number
  }

  export type usuarios_has_rolesCreateOrConnectWithoutUsuariosInput = {
    where: usuarios_has_rolesWhereUniqueInput
    create: XOR<usuarios_has_rolesCreateWithoutUsuariosInput, usuarios_has_rolesUncheckedCreateWithoutUsuariosInput>
  }

  export type usuarios_has_rolesCreateManyUsuariosInputEnvelope = {
    data: usuarios_has_rolesCreateManyUsuariosInput | usuarios_has_rolesCreateManyUsuariosInput[]
    skipDuplicates?: boolean
  }

  export type documentosUpsertWithWhereUniqueWithoutUsuariosInput = {
    where: documentosWhereUniqueInput
    update: XOR<documentosUpdateWithoutUsuariosInput, documentosUncheckedUpdateWithoutUsuariosInput>
    create: XOR<documentosCreateWithoutUsuariosInput, documentosUncheckedCreateWithoutUsuariosInput>
  }

  export type documentosUpdateWithWhereUniqueWithoutUsuariosInput = {
    where: documentosWhereUniqueInput
    data: XOR<documentosUpdateWithoutUsuariosInput, documentosUncheckedUpdateWithoutUsuariosInput>
  }

  export type documentosUpdateManyWithWhereWithoutUsuariosInput = {
    where: documentosScalarWhereInput
    data: XOR<documentosUpdateManyMutationInput, documentosUncheckedUpdateManyWithoutUsuariosInput>
  }

  export type usuarios_has_rolesUpsertWithWhereUniqueWithoutUsuariosInput = {
    where: usuarios_has_rolesWhereUniqueInput
    update: XOR<usuarios_has_rolesUpdateWithoutUsuariosInput, usuarios_has_rolesUncheckedUpdateWithoutUsuariosInput>
    create: XOR<usuarios_has_rolesCreateWithoutUsuariosInput, usuarios_has_rolesUncheckedCreateWithoutUsuariosInput>
  }

  export type usuarios_has_rolesUpdateWithWhereUniqueWithoutUsuariosInput = {
    where: usuarios_has_rolesWhereUniqueInput
    data: XOR<usuarios_has_rolesUpdateWithoutUsuariosInput, usuarios_has_rolesUncheckedUpdateWithoutUsuariosInput>
  }

  export type usuarios_has_rolesUpdateManyWithWhereWithoutUsuariosInput = {
    where: usuarios_has_rolesScalarWhereInput
    data: XOR<usuarios_has_rolesUpdateManyMutationInput, usuarios_has_rolesUncheckedUpdateManyWithoutUsuariosInput>
  }

  export type usuariosCreateWithoutUsuarios_has_rolesInput = {
    nombre?: string | null
    apellidos?: string | null
    email?: string | null
    password?: string | null
    departamentos_id?: number | null
    activo?: number | null
    documentos?: documentosCreateNestedManyWithoutUsuariosInput
  }

  export type usuariosUncheckedCreateWithoutUsuarios_has_rolesInput = {
    id?: number
    nombre?: string | null
    apellidos?: string | null
    email?: string | null
    password?: string | null
    departamentos_id?: number | null
    activo?: number | null
    documentos?: documentosUncheckedCreateNestedManyWithoutUsuariosInput
  }

  export type usuariosCreateOrConnectWithoutUsuarios_has_rolesInput = {
    where: usuariosWhereUniqueInput
    create: XOR<usuariosCreateWithoutUsuarios_has_rolesInput, usuariosUncheckedCreateWithoutUsuarios_has_rolesInput>
  }

  export type rolesCreateWithoutUsuarios_has_rolesInput = {
    tipo: $Enums.roles_tipo
    descripcion?: string | null
    activo?: boolean | null
    fecha_creacion?: Date | string | null
  }

  export type rolesUncheckedCreateWithoutUsuarios_has_rolesInput = {
    id?: number
    tipo: $Enums.roles_tipo
    descripcion?: string | null
    activo?: boolean | null
    fecha_creacion?: Date | string | null
  }

  export type rolesCreateOrConnectWithoutUsuarios_has_rolesInput = {
    where: rolesWhereUniqueInput
    create: XOR<rolesCreateWithoutUsuarios_has_rolesInput, rolesUncheckedCreateWithoutUsuarios_has_rolesInput>
  }

  export type usuariosUpsertWithoutUsuarios_has_rolesInput = {
    update: XOR<usuariosUpdateWithoutUsuarios_has_rolesInput, usuariosUncheckedUpdateWithoutUsuarios_has_rolesInput>
    create: XOR<usuariosCreateWithoutUsuarios_has_rolesInput, usuariosUncheckedCreateWithoutUsuarios_has_rolesInput>
    where?: usuariosWhereInput
  }

  export type usuariosUpdateToOneWithWhereWithoutUsuarios_has_rolesInput = {
    where?: usuariosWhereInput
    data: XOR<usuariosUpdateWithoutUsuarios_has_rolesInput, usuariosUncheckedUpdateWithoutUsuarios_has_rolesInput>
  }

  export type usuariosUpdateWithoutUsuarios_has_rolesInput = {
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    apellidos?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    departamentos_id?: NullableIntFieldUpdateOperationsInput | number | null
    activo?: NullableIntFieldUpdateOperationsInput | number | null
    documentos?: documentosUpdateManyWithoutUsuariosNestedInput
  }

  export type usuariosUncheckedUpdateWithoutUsuarios_has_rolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    apellidos?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    departamentos_id?: NullableIntFieldUpdateOperationsInput | number | null
    activo?: NullableIntFieldUpdateOperationsInput | number | null
    documentos?: documentosUncheckedUpdateManyWithoutUsuariosNestedInput
  }

  export type rolesUpsertWithoutUsuarios_has_rolesInput = {
    update: XOR<rolesUpdateWithoutUsuarios_has_rolesInput, rolesUncheckedUpdateWithoutUsuarios_has_rolesInput>
    create: XOR<rolesCreateWithoutUsuarios_has_rolesInput, rolesUncheckedCreateWithoutUsuarios_has_rolesInput>
    where?: rolesWhereInput
  }

  export type rolesUpdateToOneWithWhereWithoutUsuarios_has_rolesInput = {
    where?: rolesWhereInput
    data: XOR<rolesUpdateWithoutUsuarios_has_rolesInput, rolesUncheckedUpdateWithoutUsuarios_has_rolesInput>
  }

  export type rolesUpdateWithoutUsuarios_has_rolesInput = {
    tipo?: Enumroles_tipoFieldUpdateOperationsInput | $Enums.roles_tipo
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha_creacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type rolesUncheckedUpdateWithoutUsuarios_has_rolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipo?: Enumroles_tipoFieldUpdateOperationsInput | $Enums.roles_tipo
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha_creacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usuarios_has_rolesCreateManyRolesInput = {
    usuarios_id: number
  }

  export type usuarios_has_rolesUpdateWithoutRolesInput = {
    usuarios?: usuariosUpdateOneRequiredWithoutUsuarios_has_rolesNestedInput
  }

  export type usuarios_has_rolesUncheckedUpdateWithoutRolesInput = {
    usuarios_id?: IntFieldUpdateOperationsInput | number
  }

  export type usuarios_has_rolesUncheckedUpdateManyWithoutRolesInput = {
    usuarios_id?: IntFieldUpdateOperationsInput | number
  }

  export type documentosCreateManyTipos_documentosInput = {
    id?: number
    nombre?: string | null
    descripcion?: string | null
    mime?: string | null
    ruta?: string | null
    usuarios_id?: number | null
    fecha_subida?: Date | string | null
  }

  export type documentosUpdateWithoutTipos_documentosInput = {
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    mime?: NullableStringFieldUpdateOperationsInput | string | null
    ruta?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_subida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usuarios?: usuariosUpdateOneWithoutDocumentosNestedInput
  }

  export type documentosUncheckedUpdateWithoutTipos_documentosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    mime?: NullableStringFieldUpdateOperationsInput | string | null
    ruta?: NullableStringFieldUpdateOperationsInput | string | null
    usuarios_id?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_subida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type documentosUncheckedUpdateManyWithoutTipos_documentosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    mime?: NullableStringFieldUpdateOperationsInput | string | null
    ruta?: NullableStringFieldUpdateOperationsInput | string | null
    usuarios_id?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_subida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type documentosCreateManyUsuariosInput = {
    id?: number
    nombre?: string | null
    descripcion?: string | null
    mime?: string | null
    ruta?: string | null
    tipos_documentos_id?: number | null
    fecha_subida?: Date | string | null
  }

  export type usuarios_has_rolesCreateManyUsuariosInput = {
    roles_id: number
  }

  export type documentosUpdateWithoutUsuariosInput = {
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    mime?: NullableStringFieldUpdateOperationsInput | string | null
    ruta?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_subida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipos_documentos?: tipos_documentosUpdateOneWithoutDocumentosNestedInput
  }

  export type documentosUncheckedUpdateWithoutUsuariosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    mime?: NullableStringFieldUpdateOperationsInput | string | null
    ruta?: NullableStringFieldUpdateOperationsInput | string | null
    tipos_documentos_id?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_subida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type documentosUncheckedUpdateManyWithoutUsuariosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    mime?: NullableStringFieldUpdateOperationsInput | string | null
    ruta?: NullableStringFieldUpdateOperationsInput | string | null
    tipos_documentos_id?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_subida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usuarios_has_rolesUpdateWithoutUsuariosInput = {
    roles?: rolesUpdateOneRequiredWithoutUsuarios_has_rolesNestedInput
  }

  export type usuarios_has_rolesUncheckedUpdateWithoutUsuariosInput = {
    roles_id?: IntFieldUpdateOperationsInput | number
  }

  export type usuarios_has_rolesUncheckedUpdateManyWithoutUsuariosInput = {
    roles_id?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}